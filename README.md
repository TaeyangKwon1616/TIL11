# TIL11
## 태양이 일기랄까 너무 고되었다 오늘...
## 2025.08.09
#### 일어남.
#### 생각보다 이거 쉬운 걸지도?
#### 사진 업로드가 왜 안되지?

## 2025.08.10 TIL
#### 논리 조건식과 연속된 if문으로 바꾼 코드
```c
if ((a>10)&&(b>=0))
{
    b = 1;
}
if ((a>10)&&(b<0>))
{
    b = -1;
} 
printf("%d\n", b);

return 0;
```
#### 논리곱(&&) 연산은 두 조건을 모두 만족해야 하므로 a>10 조건이 거짓이면 두 if문의 조건식은 모두 거짓이 되어 b값은 바뀌지 않습니다. 따라서 a>10조건이 참일 때만 b의 값에 따라 둘 중 한 문장을 실행하게 됩니다. 
#### 1부터 하나씩 검사
```c
if (a == 1) 
{
    printf("일");
}
else if (a == 2)
{
    printf("이");
}
else if (a == 3)
{
    printf("삼");
}
else
{
    printf("사");
}
```
#### 두 범위로 나누어 검사 *분할 정복 기법*
```c
if (a <= 3)
{
    if (a == 1)
    {
        printf("일");
    }
    else if (a == 2)
    {
        printf("이");
    }
    else (a == 3)
    {
        printf("삼");
    }
}
else
{
    if (a == 4)
    {
        printf("사");
    }
    else if (a == 5);
    {
        printf("오");
    }
    else
    {
        printf("육");
    }
}
```
#### 이 방법을 분할 정복 기법이라고 하는데 비교 항목이 많은 경우 if 문을 여러 번 중첩해서 쓰면 실행 시간을 줄이는데 도움이 됩니다. 그러나 얼핏보면 선행조건이 필요하다고 오해할 수 있으며 코드가 읽기 어려워지므로 주의해서 사용해야 합니다.

### if ~ else if ~ else문 정리

#### 📌 개념
여러 조건을 순서대로 검사하다가, **처음으로 참인 조건을 만나면 그 부분만 실행**하고 종료하는 조건문 구조.

---

#### 📍 3가지 작성 방식

#### 1. 모든 중괄호 사용 (가장 풀어서 쓰는 형태)
```c
if (a >= 10)
{
    b = 3;
}
else
{
    if (a > 0)
    {
        b = 2;
    }
    else
    {
        b = 1;
    }
}
```
#### 2. else if로 연결 (중괄호 일부 생략)
```c
if (a >= 10)
{
    b = 3;
}
else
    if (a > 0)
    {
        b = 2;
    }
    else
    {
        b = 1;
    }
```
### 3. 깔끔한 표준 형태
여러 조건문을 간결하게 작성한 형태로, 한 줄에 조건과 중괄호를 배치해 가독성을 높임.  
실무에서 가장 많이 쓰이며, 조건 흐름을 직관적으로 파악할 수 있음.

```c
if (a >= 10) 
{
    b = 3;
}
else if (a > 0) 
{
    b = 2;
}
else {
    b = 1;
}
```
#### 결국 이 3가지 형태는 기능이 같은 문장입니다. 다만, 논리적으로는 여러개의 실행문 중에 하나를 선택하는 것이므로 시각적으로 쉽게 확인할 수 있도록 if ~ else if ~ else문의 형태로 작성하는 것이 좋습니다.
## switch ~ case 문
등수에 따라 상금을 차등 지급한다고 합시다. 1등은 300만원, 2등은 200, 3등은 100 이렇게 지급합니다. 여기서 상금의 지급 조건은 등수고, 해당 등수는 상수 1,2,3입니다. 이렇게 여러 개의 상수 중 조건에 해당하는 하나를 골라 실행하는 것이 switch~case문입니다.

```c
#include <stdio.h>

int main(void)
{
    int rank =2, m =0;
    
    switch (rank)
    {
    case 1:
        m = 300;
        break;
    case 2:
        m = 200;
        break;
    case 3:
        m = 100;
        break;
    default:
        m = 10;
        break;
    }

    printf("m : %d\n", m);
    
    return 0;

}
```
#### swith~case 문을 쓸 때에는 2가지 규칙을 꼭 지켜야 합니다.
규칙 1. 조건식으로 정수만 사용해야 합니다.
규칙 2. 기본적으로 case는 break를 포함합니다.
#### *break는 어떤 역할을 하나요?*
break는 해당 블록을 탈출하는 데 사용합니다. 이 절에서는 switch문을 빠져나올 때 사용합니다.
*defaul의 위치*
swith~case문은 조건에 따라 case의 상수를 모두 비교한 후 일치하는 상수가 없는 경우 마지막에 default로 갑니다. default는 switch의 블록 안 어디에 있어도 결과는 같습니다. 보통 모든 case문을 적은 다음 마지막에 넣어 예외 상황을 처리할 때 사용합니다.
## while문
while문은 조건식을 먼저 검사하고 조건식이 참인 동안 실행문을 반복합니다. 예를 들어 a가 10보다 작은 동안 두 배씩 반복적으로 늘리는 구문을 다음과 같이 작성할 수 있습니다.
```c
while (a < 10) // 조건식
{
    a = a * 2; // 실행문
}
```
```c
#include <stdio.h>

int main(void)
{
    int a = 1;

    while (a < 10)
    {
        a = a * 2;
    }
    printf("a : %d\n", a);

    return 0;

}
```
#### *컴파일러는 반복문의 조건식과 실행문을 모두 한 문장으로 인식합니다.
```c
if (a != 0)
    while (a<10)
    {
        a = a * 2
        printf("a의 값 : %d\n", a);
    }
```
if문에서와 비슷하게 컴파일러는 반복문의 조건식과 실행문을 모두 포함해 힌 문장으로 인식합니다. 따라서 만약 if문의 실행문이 반복문 하나로 되어 있다면 if문의 중괄호를 생략할 수 있습니다. 다만, 명확한 구분을 위해 기본적으로 중괄호를 사용하는 편이 좋습니다.
 ## for문
 while문과 비슷하게 for문도 반복문입니다. 다만, for문은 실행문을 원하느 횟수만큼 반복할 때 사용합니다. 예를들어 a값을 두 배로 증가시키는 문장을 세 번 반복하는 코드를 for문으로 작성하면 다음과 같습니다.
```c
for (i = 0, i < 3, i++)
{
    a = a * 2;
}
```

for문은 초기식, 조건식, 증감식으로 반복 횟수를 제어하면 블록 안의 문장을 반복합니다. 자세한 실행 과정은 예제를 통해 살펴보겠습니다.

#### 예제
```c
#include <stdio.h>

int main(void)
{
    int a = 1;
    int i;

    for (i = 0; i < 3; i++) //i는 0으로 초기화된 후에 3보다 작은 동안(i<3) 하나씩 증가하면서(i++)
    {
        a = a * 2;
    }
    printf("a : %d\n", a);

    return 0;

}
```
특정 횟수 만큼 반복하는 초기식, 조건식, 증감식의 조합은 많습니다. 예를 들어 다음은 모두 세번 반복하는 for문 입니다.
```c
for(i = 0; i < 3; i++)
for(i = 2; i <= 4; i++)
for(i = 0; i < 7; i +=3) // i값이 0,3,6일 때 세 번 반복
for(i = 3; i > 0; i--)
```
대부분 첫번째 형식을 많이 사용하긴 한다.

## for문 경로
i = 0(초기식) -> i < 3(조건식) -참-> a = a*2(실행문) -> i++(증감식) -> i = 0(초기식)
(조건식이 거짓이 될 때 탈출) 

*for문을 while문으로 바꿀 수 있나요?*
for문
```c
for (i = 0; i < 10; i++)
{
    printf("Be Happy!\n");
}
```
while문
```c
while (i < 10)
{
    printf("Be Happy!\n");
    i++;
}
```
## do ~ while문
while문, for문은 조건식을 먼저 확인하는 반면, do ~ while문은 일단 반복할 문장을 수행한 후에 조건을 검사합니다. 예를 들어 a값이 10보다 작은 동안 두 배씩 늘리는 문장을 do ~ while문으로 작성하면 다음과 같습니다. *do->while->do*
```c
do
{
    a = a * 2; //반복할 문장
} while (a < 10); //반복할 조건
```
do ~ while을 사용한 반복문 예제
```c
#include <stdio.h>

int main(void)
{
    int a = 1; //변수를 선언하고 1로 초기화
    do //  반복문 시작 위치
    {
        a = a * 2;
    } while (a < 10);
    printf("%d\n", a);

    return 0;
}
```
위의 코드를 while문으로 작성해도 결과는 같습니다. 그러나 a가 10으로 초기화되었다면 while문과 do ~ while문의 결과는 달라집니다. do ~ while문은 일단 먼저 실행하고 조건문으로 넘어가기에 결과값은 10에 2를 곱한 걸 먼저 실행시킨 20이 추출됩니다. 따라서 반복 조건을 검사하는 위치에 맞게 while문과 do ~ while문을 적절히 사용해야 합니다.

do ~ while문도 다른 반복문과 마찬가지로 반복할 문장이 한 문장이면 중괄호를 생략할 수 있습니다.

중괄호가 있는 코드
```c
do
{
    a = a * 2;
} while (a < 10);
```
중괄호가 없는 코드
```c
do a = a * 2; while (a < 10);
```
다만, 반복부분을 알기 쉽도록 중괄호를 사용하고 들여쓰기하는 것이 좋습니다. 그리고 do ~ while문 마지막에 붙어 있는 세미콜론(;)을 반드시 기억합시다. 세미콜론을 빠뜨렸는데 이를 인지 못하고 에러를 잡기 위해 엄한 곳을 들여다보는 경우가 꽤 발생합니다.
## do ~ while문의 특징
do ~ while문은 조건식과 관계없이 반복할 문장을 최소한 한 번은 실행합니다. while문은 조건을 만족해야지 실행문을 실행하므로 조건식이 거짓이면 실행문을 한 번도 실행하지 않고 바로 반복문을 빠져나갑니다.

## 반복문 마무리
#### while문은 반복 문장을 실행하기 전에 반복 조건을 먼저 검사한다.
#### for문은 반복 횟수가 정해진 경우에 사용하면 편리하다.
#### do ~ while문은 반복 문장을 실행한 후에 반복 조건을 검사한다.

while (조건식)
{
    실행문;
}

for(초기식; 조건식; 증감식)
{
    실행문;
}

do
{
    실행문;
} while (조건식);

## 중첩 반복문
중첩 반복문은 반복문 안에 실행할 문장으로 반복문이 포함된 것입니다. 앞서 언급했던 별을 다시 예로 들어 설명해 보겠습니다.
1 별 5개를 그린다
2 1을 세 번 반복한다.
 이 방식은 "단순한 반복문"입니다. 그런데 여기서 별 5개를 그린다는 것 또한 반복인 것을 알 수 있습니다.
 별 1개를 그린다
 2 1을 다섯번 반복한다
 3 2를 세 번 반복한다

 이러면 *중첩 반복문*입니다. 중첩 반복문의 실행과정을 이해하기는 쉽지 않습니다. 예제 코들르 통해 실행 순서를 하나씩 따라가면서 실행결과를 예상해 보겠습니다. 

```c
#include <stdio.h>

int main(void)
{
    int i, j;
    
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 5; j++)
        {
            printf("*");
        }
        printf("\n");
    }
    return 0;
}
```
실행결과
```c
*****
*****
*****
```
중첩 반복문을 이해하는 가장 좋은 방법은 반복과정에서 변하는 변숫값과 실행 문장을 확인하는 것입니다.
중첩 반복문 에서는 각 반복문이 서로 독립적인 제어 변수를 사용해야 각각 원하는 횟수를 반복할 수 있습니다. 다음 코드의 실행 결과를 예상하며 정말 그런지 확인해 보겠습니다.
```c
for (i = 0, i < 3; i++) //1번 for문
{
    for (i = 0; i < 5; i++) //2번 for문
    {
        printf("*");
    }
    printf("\n");
}
```
이 코드를 컴파일하면 동일하게 병 5개가 3줄 출력될까요? 아닙니다. 별은 다섯 번만 출력됩니다.
1번 for문의 제어 변수와 2번 for문의 제어 변수가 같으므로 2번 for문의 반복이 끝났을 때 i는 5가 됩니다. 이후 다시 바깥쪽 1번 for문의 증감식으로 올라가 i값이 6으로 증가한 후 조건 검사를 하면 곧바로 거짓이 되어 반복을 끝내게 됩니다.
## 중첩 반복문으로 구구단을 출력하는 프로그램
구구단을 출력하는 과정을 한 단계씩 만들어 가면서 중첩 빈복문을 작성하는 방법을 살펴보겠습니다.
미리 힌트를 주자면 중첩 반복문을 쓸 때에는 반복되는 기본 문장과 기본 규칙을 찾는 것이 제일 중요합니다.

구구단은 단의 수가 2단부터 9단까지 8개이므로 일단 1개의 단을 출력하는 코드를만들고 그 코드를 여덟번 반복하면 됩니다.

권태양이 짠 코드
```c
#include <stdio.h>

int main(void)
{
    int i, j, a;
    i * j = a;
    for (i = 2; i < 10; i++)
    {
        for ( j = 1, j < 10; j++)
        {
            printf("%d * %d = %d\n", i, j, a);
        }
    }

    return 0;
}
```

정답
```c
for ( i = 2; i <= 9; i++)
{
    for (j = 1; j <= 9; j++)
    {
        printf("%d * %d = %d\n", i, j, i * j);
    }
}
```
문제점 오답노트
###### *i * j = a; 문법 오류*
C언어에서 i * j = a;는 의미가 없어요.
*는 곱셈 연산자이지, 변수 선언할 때 쓰는 게 아니고, 곱셈 결과에 값을 대입할 수도 없습니다.
아마도 a = i * j;로 하려고 했던 것 같습니다.
###### *for 문 조건부에 , 사용*
for ( j = 1, j < 10; j++)
여기서 ,는 콤마 연산자라, 실제로는 첫 번째 식 j = 1만 실행되고 j < 10은 무시됩니다.
, 대신 ;를 써야 합니다.
즉, for ( j = 1; j < 10; j++)
###### *곱셈 결과를 출력하기 전에 계산 안 함*
a 값은 i와 j의 곱을 저장해야 하므로, 내부에서 a = i * j;를 해야 합니다.
#### *내부에서 해야하는 이유*
###### *a 값은 i와 j의 곱을 담는 변수*
i와 j는 for문이 돌면서 계속 변하는 값이에요.
예를 들어,
첫 번째 반복: i = 2, j = 1 → 곱은 2
두 번째 반복: i = 2, j = 2 → 곱은 4
매 반복마다 다른 값이 나오니까, 매번 새로 계산해야 합니다.
###### *내부에서 안 하면 생기는 문제*
만약 a = i * j;를 for문 밖에 둔다면,
그 순간에 i와 j가 딱 한 번만 계산되고,
그 후로는 a 값이 그대로 유지되어 구구단 전체가 같은 결과를 찍게 됩니다.

#### 내가 했던 오답을 정답으로 고친 것
```c
#include <stdio.h>

int main(void)
{
    int i, j, a;

    for (i = 2; i < 10; i++)
    {
        for (j = 1; j < 10; j++)
        {
            a = i * j; // 곱셈 결과 저장
            printf("%d * %d = %d\n", i, j, a);
        }
    }

    return 0;
}
```
## break와 continue 분기문
#### break
break는 반복문 안에서 반복을 즉시 끝낼 때 사용합니다. 모든 반복문은 조건식이 거짓일 때 반복이 끝납니다. 따라서 반복문 처음에 조건식이 있는 while문이나 for문은 반복문 위에서 반복이 끝나고 마지막에 조건식이 있는 do~while문은 반복문 밑에서 반복이 끝납니다. 그런데 예외적으로 반복문 중간에서 임의로 반복을 끝내고 싶을 때는 break를 사용합니다. if (조건식) break;
#### break를 사용한 반복문 종료
```c
#include <stdio.h>

int main(void)
{
    int i;
    int sum = 0;

    for (i = 1; i <= 10; i++)
    {
        sum += i;
        if (sum > 30) break;
    }

    printf("누적한 값 : %d\n", sum);
    printf("마지막으로 더한 값 : %d\n", i);

    return 0;

}
```
#### break로 무한 반복문 빠져 나오기
반복문의 조건식이 항상 참이면 무한 반복문이 됩니다.
```c
while(1) //1은 참을 의미.
{
    printf("Be happy!\n");
}
```
조건식에 사용된 1은 참을 의미하며 반복 과정에서 변하지 않으므로 출력문은 무한 반복 됩니다. for문으 사용할 때는 괄호 안에 세미콜론을 2개 사용합니다.
```c
for (;;)
{
    printf("Be happy!\n");
}
```
무한 반복문은 기본적으로 무한히 반복되므로 반복을 끝낼 때에는 조건에 따라 break를 사용합니다.

```c
count = 0;
while (1)
{
    printf("Be happy!\n");
    count++;
    if (count == 5) break;
}
```
##### ***if문과 달리 switch ~ case문의 블록 안에서 break를 사용하면 switch~case 블록만 벗어납니다***

#### continue
continue는 반복문의 일부를 건너뜁니다. 반복문 안에서 continue를 사용하면 다음 살행 위치가 반복문의 블록 끝이 됩니다. 블록을 탈출하는 것은 아닙니다. 따라서 조건에 따라 반복문의 일부를 제외하고 반복할 수 있습니다. 예를 들어 3의 배수를 빼고 1부터 100까지의 합을 구할 때 효과적으로 사용할 수 있습니다.
```c
for (i = 1; i <= 100; i++)
{
    if ( (i % 3) == 0)
    {
        continue; // i가 3의 배수면 sum += i 문장을 건너뛰고 블록 끝으로 간 후에 다시 반복합니다.
    }
    sum += i;
}
```
continue에 의해서 제어가 블록의 끝으로 이동한 후에는 다시 반복이 시작됩니다. 결국 다음 실행 위치는 증감식이 됩니다.

#### while문에서 continue 사용 시 유의점
for문과 달리 while문에서 continue를 사용하면 다음 실행 위치가 조건식이 됩니다,. 만약 위의 for문을 다음과 같이 while문으로 바꾸면 증감식이 실행되지 않으므로 무한 반복됩니다.
```c
i = 1;
while (i <= 100)
{
    if ((i % 3) == 0 )
    {
        continue; // i가 3일 때 증감식 i++를 건너뛰므로 while문의 조건식은 계속 참이 됩니다.
    }
    sum += 1;
    i++;
}
```
#### GPT한테 물어본 while문에서 continue 사용법
좋은 잘문이에요. while문 안에서 **continue**는 이번 반복을 건너뛰고 바로 다음 반복으로 넘어가라는 뜻이에요.
#### 예시 1: 짝수만 출력하기

```c
#include <stdio.h>
int main(void)
{
    int i = 0;

    while (i < 10)
    {
        i++; //i를 1증가
        
        if (i % 2 == 1) //홀수일 때 밑에 코드 무시하고 while 처음으로
        {
            continue;
        }
        printf("%d\n", i); //짝수만 출력됨
    }
    return 0;
}
```
#### i가 홀수면 -> continue 실행 -> printf 건너뜀
#### i가 짝수면 -> continue 안열림 -> printf 실행 

#### 예시 2 : 특정 값만 건너뛰기
```c
#include <stdio.h>
int main(void)
{
    int i = 0;
    while (i < 5)
    {
        i++;
        if(i == 3)
        {
            continue; // i가 3일 때만 출력 생략
        }
        printf("%d\n", i);
    }
    return 0;
}
```
-> i == 3 일 때 continue 때문에 출력하지 않고 바로 반복문 처음으로 넘어감.

#### 정리하면
continue; -> 아래 코드를 무시하고 반복문의 처음으로 돌아감. while에서는 continue 실행시 -> 조건 검사(while(조건))로 바로 이동

# 함수
함수란 기능을 수행하는 코드 단위를 말합니다. 지금까지 사용해 왔던 main 함수가 대표적인 함수 입니다. 그리고 printf와 scanf도 함수입니다. printf마 scanf함수처럼 특정 기능을 미리 약속하고 프로그램에서 바로 사용할 수 있게 구현되어 있는 함수를 "표준 라이브러리 함수"라고 합니다. printf나 scanf함수는 모든 예제에 있던 stdio.h 헤더 파일에 포함되어 있습니다.

#### 이처럼 C언어에서 표준으로 제공하는 함수 외에도 자주 사용하는 코드를 함수로 만들어 필요할 때 사용할 수도 있습니다. 함수를 만들려면 다음의 3가지가 중요합니다.
함수 정의 : 함수를 실제 코드로 만드는 것으로 함수의 기능을 구현 합니다.
함수 호출 : 함수 호출을 해야지 함수를 사용할 수 있습니다.
함수 선언 : 프로그램의 상단에서 어떤 함수를 사용할 것이라고 컴파일러에 정보를 주는 역할을 합니다.

#### 예를 들어 두 정수의 합을 자주 계산하는 경우 해당 기능을 함수로 만들면 필요할 때 호출만 하면 되므로 편리 합니다.

## 새로운 함수를 만드는 방법도 main 함수를 만드는 방법과 크게 다르지 않습니다. 다만, 함수를 만들기 전에 다음 3가지를 먼저 생각해 보겠습니다.

#### 1 함수의 기능에 맞는 이름은 무엇인가?
#### 2 함수가 기능을 수행할 때 필요한 데이터는 무엇인가?
#### 3 함수가 수행된 후의 결과는 무엇인가?

#### 이 3가지에 맞춰서 다시 두 정수의 합을 구하는 함수를 만든다고 가정해 보겠습니다.
이 3 가지에 맞춰서 다시 두 정수의 합을 구하는 함수를 만든다고 가정해 보겠습니다.
#### 
#### 1 함수의 기능에 맞는 이름은 무엇인가? //함수명
-> 구현하려는 기능 = 더하기 = 영어로는 sum
#### 2 함수가 기능을 수행하는 데 필요한 데이터는 무엇인가? //매개변수
-> 더하려는 정수
#### 3 함수가 수행된 후의 결과는 무엇인가? //반환형
-> 정수(정수 2개를 더한 값은 정수)

####간단하게 답한 이 질문이 바로 함수 원형(function prototype)을 이룹니다. 이 내용을 코드 형식으로 쓰면 다음과 같습니다.
```c
###### 함수 정의
###### 반환형 함수명(매개변수1, 매개변수2)
###### {
###### //함수가 수행하는 명령. 결괏값(매개변수1 + 매개변수2)을 돌려보냄
###### }
```
## 2개의 함수로 만든 프로그램
```c
#include <stdio.h>

int sum(int x, int y); //sum 함수 선언

int main(void) //main 함수 시작
{
    int a = 10, b = 20;
    int result; // 두 정수를 더한 결과(result)를 저장할 변수

    result = sum(a,b); //sum 함수 호출
    printf("result : %d\n", result);

    return 0;
} // main 함수의 끝
 
 int sum(int x, int y) //sum 함수 정의 시작
 {
    int temp; // 두 정수의 합을 잠시 저장할 변수

    temp = x + y; // x와 y의 합을 temp에 보관

    return temp; //temp의 값을 변환
 } //sum 함수의 끝
 ```
우선 함수를 만드는 함수 정의 위치부터 살펴봅시다. 함수를 다른 함수 안에서 정의할 수는 없습니다. 따라서 sum 함수는 main함수와 별도의 구역(16~23행)에 만듭니다. 함수를 만들 때는 함수의 원형을 먼저 작성합니다. 16행이 함수 원형을 만드는 부분이며 여기서 반환형, 함수명, 매개변수를 표시합니다.
#### int[반환형] sum[함수명](int x, int y)[매개변수] // 16행 함수 원형

#### ***cf***반환형
반환형은 함수가 기능을 수행한 후 호출한 곳으로 돌려줄 값의 자료형을 적습니다. 즉 sum함수는 두 정수의 합을 반환해야하므로 자료형으로 int를 사용합니다.
```c
int sum(int x, int y)
{
    int temp; // ~

    temp = x + y; // 

    return temp; // ~ 실제 함수의 내용 함수가 수행하는 명령
}
```
함수 내에서 필요한 변수가 있다면 18행과 같이 별도로 선언합니다.
 ```c
 int temp; //18행. 두 정수의 합을 잠시 저장할 변수
```
매개변수의 합을 더해서 변수 temp에 잠시 저장했다가 return문에서 변수 temp에 저장해 두었던 값을, 함수를 호출한 곳으로 반환합니다. 여기서 temp는 기능상 꼭 필요한 변수가 아니므로 return (x +y);과 같이 두 수의 합을 바로 반환하는 것도 가능합니다.
// return은 함수의 실행결과를 돌려주는 제어문입니다.

#### temp에 두 수의 합을 저장하는 코드
```c
int sum(int x + int y)
{
    int temp;

    temp = x + y;

    return temp;
}
```
#### temp가 없는 코드
```c
int sum(int x, int y)
{
    return (x + y); //두 수의 합을 바로 반환
}
```
#### 함수 속 변수명
함수에서 사용하는 변수명에 관해 잠깐 생각해 봅시다. 함수 안에서 사용하는  변수명은 다른 함수의 변수명과 같아도 됩니다. 다시 말해, sum의 함수의 변수명을 main 함수의 변수명과 같은 이름으로 선언할 수 있습니다.
```c
int sum(int a, int b) //매개변수 a,b는 main함수의 변수와 이름이 같음
{
    int result; //main 함수에도 result 변수명이 있음.

    result = a + b; // a,b는 main함수의 a,b가 아니고 매개변수 a,b를 말함.

     return result;
}
```
#### 왜 그럴까?
***컴파일러는 변수명의 사용 범위를 선언한 블록 내부를 제한합니다.*** 따라서 둘 이상의 함수에서 같은 이름의 변수를 선언해도 중복에러가 발생하지 않습니다. 이 경우 각 변수는 함수별로 독립된 저장 공간을 가지며 함수 내에서만 사용할 수 있습니다.

## 함수 호출
지금까지 함수를 만들어 봤습니다. 함수는 얼마든지 만들 수 있지만, 만든 함수가 모두 자동으로 실행되는 것은 아닙니다. 함수를 사용하려면 먼저 함수 호출을 해야합니다. 

#### 함수를 호출할 때에는 이름을 사용하며 함수에 필요한 데이터를 괄호 안에 넣어 주는데, 이를 "인수"라고 합니다.
sum 함수를 호출해서 a와 b를 더하려면 함수명과 함께 괄호 안에 a,b를 넣고 호출합니다. 인수는 상수나 변수를 쓸 수 있고 수식을 사용하면 수식의 결괏값이 인수로 쓰입니다.
#### sum[함수명](30, 40)[상수 인수], sum[함수명](a*2, b/3)[수식 인수]
함수를 호출할 때 이렇게 입력된 인수 a,b의 값은 호출된 함수의 매개변수에 복사되어 사용됩니다. 다시 코드를 보면 sum 함수가 호출되면 main함수의 실행은 잠시 멈추고 비로소 sum 함수 정의 부분에 있는 코드가 실행됩니다. 이때 인수는 함수의 매개변수에 순서대로 복사되어 sum 함수 안에서 사용됩니다. 

## 함수 반환
호출된 함수의 실행이 끝나고 값을 반환할 때 return문을 사용합니다. 다음 코드를 보면 sum함수는 x와 y를 더하고 그 값을 temp에 저장한 뒤 함수의 실행을 끝내고 호출한 곳으로 돌아가기 위해 return문을 사용합니다. 이때 temp의 값을 호출한 곳으로 반환합니다. 이후 main 함수는 반환된 값을 대입 연산으로 result에 저장하고 잠시 중단했던 함수의 나머지 부분을 실행합니다.

## 함수 선언
함수 선언은 컴파일러가 새로 만든 함수를 인식할 수 있도록 알리는 역할을 합니다.
#### int[반환형] sum[함수명](int x, int y)[매개변수];
선언 방법은 간단합니다. 세미콜론을 붙이면 됩니다. 함수 선언은 main함수 앞에 하며 다음처럼 매개변수 이름은 생략할 수 있습니다.
```c
int sum(int, int) //매개변수 이름을 생략한 형태
```
그런데 엄연히 함수 정의가 있는데 왜 함수 선언이 필요할까요?
#### 이유 1 함수 선언에서 반환값의 형태를 확인합니다.
컴파일러는 컴파일할 때 함수를 호출한 자리에 반환값과 같은 형태의 저장 공간을 준비합니다. 즉, 정수를 반환하면 호출한 자리에 int형 공간을 확보하고 실수를 반환하면 double형 공간을 확보합니다. 따라서 함수를 호출하기 전에 선언을 통해 반환형을 미리 컴파일러에 알릴 필요가 있습니다. 물론 함수 정의에서도 반환형을 확인할 수 있으므로 함수 호출 이전에 함수를 정의하는 방법도 있습니다.

#### main 함수 앞에 sum 함수를 정의하면 함수 정의에 원형이 포함되므로 따로 함수를 선언할 필요가 없습니다. 코드를 방금 설명한 순서로 바꿔도 실행 순서는 변하지 않습니다. 프로그램은 항상 main 함수부터 시작하며 그 이후에는 호출 순서에 따라 실행되기 때문입니다.

### ***cf***함수 선언이 없으면 함수 정의는 항상 함수 호출 이전에 있어야 합니다.
함수를 미리 선언하지 않으려면 항상 호출하는 함수 앞에 정의해야합니다. 이때 여러 함수 간에 호출 관계가 엉켜있다면 순서에 맞게 정의하는 일이 쉽지 않습니다. 따라서 필요한 함수를 main함수 밑에 차례로 만들고 main함수 앞에는 모든 함수를 선언해 함수의 종류와 원형을 한눈에 파악하고 자유롭게 호출할 수 있도록 작성하는 것이 좋습니다. 또한 분할 컴파일하는 프로그램에서 호출하는 함수와 호출되는 함수가 서로 다른 파일에 있으면 반드시 선언이 필요합니다.

### 함수의 호출 형식에 문제가 없는지 검사합니다. 
함수 선언문에는 매개변수의 개수와 형태에 대한 정보가 있으므로 호출할 때 정확한 값을 주는지 검사할 수 있습니다. 예를 들어 sum 함수에 필요한 값이 정수 2개인데 인수로 실수를 주고 호출하면 컴파일 단계에서 확인하고 경고 메시지로 문제점을 알려 줍니다.
 
 ## 여러 가지 함수 유형
 함수 원형은 반환형 함수명(매개변수)로 이루어진다고 배웠습니다. ***하지만 언제나 함수에 반환형과 매개변수가 있는 것은 아닙니다.*** 앞의 sum함수는 두 수를 더하는 함수였기에 매개변수가 필요했습니다. 그런데 단순히 키보드 값을 확인하고 양수를 반환하는 함수라면 어떨까요? 이때는 매개변수가 필요 없습니다. scanf함수로 바로 입력을 받으면 될 테니까요.

 #### 매개변수가 없는 함수
 ```c
 #include <stdio.h>

 int get_num(void); //함수 선언

 int main(void)
{
    int result;
    
    result = get_num(); //함수 호출, 반환값은 result에 저장, get_num 함수는 매개변수가 없습니다. 당연히 호출할 때 인수가 없습니다. 그렇다면 get_num으로 적어도 될까요? 아니면 get_num(void)로 적어야 할까요? 둘 다 아닙니다. void는 함수 정의나 선언에서 적용되며 호출할 때는 쓰지 않습니다. 그냥 괄호만 쓰면 됩니다. 괄호 조차 없다면 함수를 호출하는 문장이 아닌 그냥 함수의 이름으로 인식하므로 반드시 괄호는 사용해야 합니다.
    printf("반환값 : %d\n", result); //반환값 출력
    return 0;
}

int get_num(void) //매개변수가 없고 반환형만 있다.
{
    int num; //키보드 입력값을 저장할 변수

    printf("양수 입력 : "); //입력 안내 메시지
    scanf("%d\n", &num); //키보드 입력

    return num; //입력한 값 변환
}
```
괄호 안에 void를 넣어 매개변수가 없음을 표시합니다. 괄호만 사용해도 매개변수가 없다는 사실을 표시할 수 있지만, void를 넣어 매개변수가 없음을 명시적으로 표현하는 것이 좋습니다. get_num 함수는 매개변수가 필요 없지만, 키보드로 입력받은 값을 호출 함수로 반환하므로 반환형(int)은 있어야 합니다. 또한 반환하는 문장 return num;도 필요합니다.

## 음수 입력에 대응합시다
get_num 함수는 양수를 입력받아 반환하는 작업을 처리합니다. 더 욕심을 부려 음수가 입력될 때 경고 메시지를 출력하고 다시 입력 받도록 수정해보겠습니다.
```c
int get_num(void)
{
    int num;
    printf("양수 입력 : \n");
    scanf("%d", &num);
    while (num < 0)
    {
        printf("양수를 입력하세요!\n");
        printf("양수 입력 : \n");
        scanf("%d", &num);
    }
    return num;
}
```
이처럼 프로그램을 실행하다가 발생할 수 있는 예외 상황에 대비해 코드를 추가하는 것이 바로 ***예외 처리*** 입니다.

## 반환값이 없는 함수
함수는 기능에 따라 형태가 결정됩니다. 데이터를 받아서 단지 화면에 출력하는 함수라면 반환값이 필요 없습니다.
#### 예를 들어 문자와 숫자를 인수로 받으면 문자를 숫자만큼 화면에 출력하는 함수를 생각해 보겠습니다. 화면에 출력한 내용이 함수가 수행한 결과이므로 호출한 곳으로 특별히 값을 반환할 필요가 없습니다. 매개변수의 빈자리에 void를 사용했던 것처럼 반환형의 자리에 void를 사용했던 것처럼 반환형의 자리에 void를 사용합니다.
```c
#include <stdio.h>

void print_char(char ch, int count); //함수 선언

int main(void)
{
    print_char('@',5); //문자와 숫자를 두고 함수 호출

    return 0;
}

void print_char(char ch, int count) //매개변수는 있으나 반환형은 없다.
{
    int i;

    for (i = 0; i < count; i++) //i는 0부터 count-1까지 증가, count번 반복
    {
        printf("%c", ch); //매개변수 ch에 받은 문자 출력
    }
    return;
}
```
문자와 숫자를 받아야 하므로 매개변수는 있으나 반환형은 void를 사용합니다.
또한 반환값이 없으므로 return문은 값 없이 단독으로 사용합니다.
#### return의 역할이 값을 돌려주는 일인데, 돌려줄 값이 없으므로 자연스럽게 혼자 쓰입니다. 심지어 retrun문 자체를 생략하는 것도 가능합니다. return 문이 없어도 함수의 코드를 모두 수행하면 호출한 곳으로 자동으로 돌아갑니다.

만약 함수 실행 중간에 돌아가야 한다면 return문을 함수 어디서든 사용할 수 있습니다. 예를 들어 count의 값이 10보다 큰 경우 바로 함수를 끝내고 싶다면 다음과 같이 함수 중간에 return문을 사용하면 됩니다. 이때도 return문만 단독으로 사용합니다.
```c
void print_char(char ch, int count)
{
    int i;
    if (count > 10) return; //여기서 return하면 함수의 실행을 종료한다
    for (i = 0; i < count; i++)
    {
        printf("%c",ch);
    }
    return;
}
```

## 매개변수와 반환값이 모두 없는 함수
매개변수와 반환값이 모두 없는 함수도 있습니다. 예를 들어 일정한 문자열을 여러 번 출력하는 함수라면 매개변수와 반환값이 모두 필요 없습니다. 이때는 함수의 매개변수와 반환형에 모두 void를 씁니다. 반환값과 매개변수가 모두 없는 함수를 단단히 만들어 살펴보겠습니다.

```c
#include <stdio.h>

void print_line(void);

int main(void)
{
    print_line();
    printf("학번    이름    전공    학점\n");
    print_line();
    
    return 0;
}
void print_line(void)
{
    int i;
    
    for (i = 0; i < 50; i++)
    {
        printf("-");
    }
    printf("\n");
}
```
## 재귀호출 함수
함수는 보통 다른 함수를 호출하는데 재귀호출 함수는 자기 자신을 호출합니다는 어렵지만 만들기는 쉽습니다. 우선 간단하게 apple을 출력하는 재귀호출 함수부터 살펴보겠습니다.
```c
#include <stdio.h>

void fruit(void); //함수 선언

int main(void)
{
    fruit(); // 함수 호출

    retrun 0;
}

void fruit(void) //재귀호출 함수 정의
{
    printf("apple\n");
    fruit(); // 자신을 다시 호출
}
```
#### ***왜 무한으로 apple을 출력하지 않고 종료할까요?***
함수는 호출만으로도 일정 크기의 메모리를 사용하므로 프로그램 하나가 쓸 수있는 메모리(해당 프로세스에 할당된 스택 메모리)를 모두 사용하게 되어 메모리부족으로 강제 종료됩니다. 따라서 컴파일러는 컴파일 과정에서 경고메시지를 띄워 알려줍니다.

### 세 번 실행되는 재귀호출 함수
```c
#include <stdio.h>

void fruit(int count);

int main(void)
{
    fruit(1);
    
    return 0;
}

void fruit(int count) //호출 횟수를 매개변수에 저장
{
    printf("apple\n");
    if (count == 3) return; //호출 횟수가 3이면 반환하고 끝낸다.
    fruit(count + 1); // 재호출할 때 호출 횟수를 1 증가
}
```
### 재귀호출과 반복문의 차이점
여기까지 잘 따라왔다면 '재귀 호출 대신 그냥 반복문을 사용해도 되지 않을까?'라는 의구심이 들겁니다. 재귀 호출과 반복문은 어떤 차이가 있는지 에제로 살펴보겠습니다.
```c
#include <stdio.h>

void fruit (int count);

int main(void)
{
    fruit(1);

    return 0;
}

void fruit (int count)
{
    printf("apple\n");
    if (count == 3 ) return; //15행
    fruit(count + 1);
    print("jam\n"); //17행
}
```
재귀호출 이후 17행에 출력문을 하나 더 넣었습니다. 15행의 return문이 최초 호출한 main함수로 돌아간다면 17행은 절대 실행되지 않을 겁니다. 그러나 예상과 달리 실행결과를 보면 17행이 실행되어 jam이 두번 출력되었습니다.
#### 왜 그럴까요? 재귀호출 함수의 경우 최초 호출한 곳이 아니라 이전에 호출했던 곳으로 돌아갑니다. 이 상황은 재귀 호출이 수행될 때마다 함수의 복사본을 만들어 보면 쉽게 이해할 수 있습니다.

# 배열
## 배열의 선언과 사용
지금까지 메모리에 저장 공간을 확보할 때 변수를 선언했습니다. 예를 들어 다섯 과목의 점수를 처리 하고싶어서 다음과 같이 점수를 int형 변수로 하나씩 개별적으로 선언했다고 가정합시다.
#### int kor, math, eng, social, science;
이렇게 하나씩 따로따로 선언하면 점수도 일일이 하나씩 변수에 넣어주어야 합니다. 즉, 반복문 사용이 불가능합니다. 왜냐하면 이름이 별도로 있기 때문입니다. 그래서 우리는 같은 형태의 많은 데이타를 반복문으로 처리하기 위해서 메모리에 연속적으로 저장해 놓고 쪼개서 사용하는 방법을 사용합니다. 이를 "배열"이라고 합니다.

## 배열의 선언
배열 또한 다른 자료형처럼 선언을 통해서 저장 공간을 확보합니다. 다만, 다섯 과목의 점수를 처리할 때 기존처럼 int형 변수를 하나씩 선언하지 않고, 하나의 이름으로 한꺼번에 확보합니다. 또 저장 공간의 개수와 관계없이 이름은 하나만 사용합니다.
#### 배열을 선언하는 방법은 간단합니다. 요소의 자료형에 이름을 붙이고 필요한 요소의 개수를 표시합니다. 요소가 5개인 배열을 선언하는 예는 다음과 같습니다.
```c
int ary[5];
```
배열명은 변수명을 짓는 규칙에 따라 적절한 이름을 사용합니다. 배열을 하나 선언한 다음 5명의 나이를 저장하고 사용하는 방법을 예제로 확인해 보겠습니다.
```c
#include <stdio.h>

int main(void)
{
    int ary[5]; //int형 요소 5개의 배열 선언

    ary[0] = 10; //ary는 array의 축약어
    ary[1] = 20;
    ary[2] = ary[0] + ary[1];
    scanf("%d", &ary[3]);

    printf("%d\n", ary[2]);
    printf("%d\n", ary[3]);
    printf("%d\n", ary[4]); //마지막 배열 요소는 쓰레기값

    return 0;

}
```
int형 변수는 크기가 4바이트이므로 5개를 연속으로 할당하면 총 20바이트가 됩니다. 배열요소는 배열명에 첨자(index)를 붙여 표현하며 첨자는 0부터 시작합니다.

## 배열 초기화
배열도 변수와 마찬가지로 최초할당된 저장 공간에는 쓰레기 값이 저장되어 있습니다. 그러므로 배열도 원하는 값을 가지려면 선언과 동시에 초기화해야 합니다. 배열은 중괄호({})로 묶어서 초기화합니다.
#### 기본적인 초기화 방법입니다.
```c
int ary[5] = {1,2,3,4,5};
```
초깃값은 첫 번째 요소부터 차례로 초기화됩니다.
#### 초깃값이 배열의 요소의 개수보다 적은 경우입니다.
```c
int ary[5] = {1,2,3};
```
이때는 왼쪽부터 차례로 초기화하고 남은 배열 요소느 모두 0으로 채웁니다. ary[0]부터 ary[2]까지 각 1,2,3이고 ary[3], [4]는 모두 0.
#### 자동 초기화 기능을 사용할 수도 있습니다.
```c
int ary[1000] = {0};
```
이러면 배열 요소 개수가 아무리 많아도 모든 요소를 쉽게 0으로 초기화할 수 있습니다.
#### 배열 요소 개수가 생략된 형태도 있습니다.
```c
int ary[] = {1,2,3};
```
이 경우 컴파일러는 초깃값 개수만큼 배열 요소 개수를 정하고 저장공간을 할당 합니다. 즉, 다음과 같은 메모리에 저장공간이 할당되고 초기화 됩니다.
#### ary[0] = 1, ary[1] = 2, ary[2] = 3
#### double형 배열과 char형 배열을 선언하고 초기화 합니다. 각각의 자료형에 맞게 double형 배열은 실수 값으로 초기화되고, char형 배열은 문자로 초기화 됩니다.
#### double ary[5] = {1.0, 2.1, 3.2, 4.3, 5.4};
#### char ary[5] = {'a','p','p','l','e'};
char형 배열은 주로 문자열을 저장하는 용도로 사용된다.
#### 배열의 초기화는 선언시 최초 한 번만 가능합니다. 그 이후에는 배열 요소에 일일이 값을 대입해야 하며, 초기화 때처럼 중괄호({})를 사용한 대입 연산으로 한 번에 값을 바꾸는 것은 불가능합니다.

## 배열과 반복문
연속된 저장공간을 할당하고 초기화할 수 있어 같은 유형의 변수가 많이 필요할 때 배열을 사용한다고 했습니다. 이렇게 연속된 배열 요소를 일일이 변수처럼 하나씩 떼어서 사용한다면, 이는 배열을 제대로 활용하고 있지 못한 것입니다. 배열 요소가 5개인 배열에 정수를 입력하는 다음 예시를 볼까요?
```c
int score[5];

scanf("%d", &score[0]);
scanf("%d", &score[1]);
scanf("%d", &score[2]);
scanf("%d", &score[3]);
scanf("%d", &score[4]);
```
언뜻 봐도 같은 작업을 반복하고 있으며 바뀌는 것은 첨자 뿐입니다. 따라서 반복문을 사용하면 간단히 구현할 수 있습니다. 예제를 통해 확인해보겠습니다.
```c
#include <stdio.h>

int main(void)
{
int score[5];
int i;
int total = 0;
double avg;
for (i =0; i < 5; i++)
{
    scanf("%d", &score[i]);
}
for (i = 0; i < 5; i++)
{
    total += score[i];
}
avg = total / 5.0;

for (i = 0; i < 5; i++)
{
    printf("%d\n", score[i]);
}
printf("\n");

printf("평균 : %.1lf\n",avg);

return 0;
}
```

## sizeof 연산자를 활용한 배열 처리
보통 많은 양의 데이터를 처리하므로 배열을 다룰 때는 반복문 사용이 필수입니다. 따라서 배열 요소의 개수가 바뀌면 배열을 처리하는 반복문을 모두 수정해야하는 부담이 있습니다. 이 문제의 해결책으로 배열 요소의 개수를 직접 계산해 반복문에 사용하는 방법을 사용할 수 있습니다.

#### 배열 요소의 개수는 다음과 같이 구합니다.
```c
#### sizeof(배열명) / sizeof(배열 요소)
```
```c
#include <stdio.h>

int main(void)
{
    int score[5];
    int i;
    int total = 0;
    double avg;
    int count;

    count = sizeof(score) / sizeof(score[0]);

    for (i = 0; i < count; i++)
    {
        scanf("%d", &score[i]);
    }
    for (i =0; i < count; i++) // 11행에서 계산한 count만큼 반복
    {
        total += score[i];
    }
    avg = total / (double)count;

    for (i = 0; i < count; i++)
    {
        printf("%5d\n", score[i]);
    }
    printf("\n");

    printf("평균 : %.1lf\n", avg);
    
    return 0;
}
```
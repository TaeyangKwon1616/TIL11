# TIL11
## 태양이 일기랄까 너무 고되었다 오늘...
## 2025.08.09
#### 일어남.
#### 생각보다 이거 쉬운 걸지도?
#### 사진 업로드가 왜 안되지?

## 2025.08.10 TIL
#### 논리 조건식과 연속된 if문으로 바꾼 코드
```c
if ((a>10)&&(b>=0))
{
    b = 1;
}
if ((a>10)&&(b<0>))
{
    b = -1;
} 
printf("%d\n", b);

return 0;
```
#### 논리곱(&&) 연산은 두 조건을 모두 만족해야 하므로 a>10 조건이 거짓이면 두 if문의 조건식은 모두 거짓이 되어 b값은 바뀌지 않습니다. 따라서 a>10조건이 참일 때만 b의 값에 따라 둘 중 한 문장을 실행하게 됩니다. 
#### 1부터 하나씩 검사
```c
if (a == 1) 
{
    printf("일");
}
else if (a == 2)
{
    printf("이");
}
else if (a == 3)
{
    printf("삼");
}
else
{
    printf("사");
}
```
#### 두 범위로 나누어 검사 *분할 정복 기법*
```c
if (a <= 3)
{
    if (a == 1)
    {
        printf("일");
    }
    else if (a == 2)
    {
        printf("이");
    }
    else (a == 3)
    {
        printf("삼");
    }
}
else
{
    if (a == 4)
    {
        printf("사");
    }
    else if (a == 5);
    {
        printf("오");
    }
    else
    {
        printf("육");
    }
}
```
#### 이 방법을 분할 정복 기법이라고 하는데 비교 항목이 많은 경우 if 문을 여러 번 중첩해서 쓰면 실행 시간을 줄이는데 도움이 됩니다. 그러나 얼핏보면 선행조건이 필요하다고 오해할 수 있으며 코드가 읽기 어려워지므로 주의해서 사용해야 합니다.

### if ~ else if ~ else문 정리

#### 📌 개념
여러 조건을 순서대로 검사하다가, **처음으로 참인 조건을 만나면 그 부분만 실행**하고 종료하는 조건문 구조.

---

#### 📍 3가지 작성 방식

#### 1. 모든 중괄호 사용 (가장 풀어서 쓰는 형태)
```c
if (a >= 10)
{
    b = 3;
}
else
{
    if (a > 0)
    {
        b = 2;
    }
    else
    {
        b = 1;
    }
}
```
#### 2. else if로 연결 (중괄호 일부 생략)
```c
if (a >= 10)
{
    b = 3;
}
else
    if (a > 0)
    {
        b = 2;
    }
    else
    {
        b = 1;
    }
```
### 3. 깔끔한 표준 형태
여러 조건문을 간결하게 작성한 형태로, 한 줄에 조건과 중괄호를 배치해 가독성을 높임.  
실무에서 가장 많이 쓰이며, 조건 흐름을 직관적으로 파악할 수 있음.

```c
if (a >= 10) 
{
    b = 3;
}
else if (a > 0) 
{
    b = 2;
}
else {
    b = 1;
}
```
#### 결국 이 3가지 형태는 기능이 같은 문장입니다. 다만, 논리적으로는 여러개의 실행문 중에 하나를 선택하는 것이므로 시각적으로 쉽게 확인할 수 있도록 if ~ else if ~ else문의 형태로 작성하는 것이 좋습니다.
## switch ~ case 문
등수에 따라 상금을 차등 지급한다고 합시다. 1등은 300만원, 2등은 200, 3등은 100 이렇게 지급합니다. 여기서 상금의 지급 조건은 등수고, 해당 등수는 상수 1,2,3입니다. 이렇게 여러 개의 상수 중 조건에 해당하는 하나를 골라 실행하는 것이 switch~case문입니다.

```c
#include <stdio.h>

int main(void)
{
    int rank =2, m =0;
    
    switch (rank)
    {
    case 1:
        m = 300;
        break;
    case 2:
        m = 200;
        break;
    case 3:
        m = 100;
        break;
    default:
        m = 10;
        break;
    }

    printf("m : %d\n", m);
    
    return 0;

}
```
#### swith~case 문을 쓸 때에는 2가지 규칙을 꼭 지켜야 합니다.
규칙 1. 조건식으로 정수만 사용해야 합니다.
규칙 2. 기본적으로 case는 break를 포함합니다.
#### *break는 어떤 역할을 하나요?*
break는 해당 블록을 탈출하는 데 사용합니다. 이 절에서는 switch문을 빠져나올 때 사용합니다.
*defaul의 위치*
swith~case문은 조건에 따라 case의 상수를 모두 비교한 후 일치하는 상수가 없는 경우 마지막에 default로 갑니다. default는 switch의 블록 안 어디에 있어도 결과는 같습니다. 보통 모든 case문을 적은 다음 마지막에 넣어 예외 상황을 처리할 때 사용합니다.
## while문
while문은 조건식을 먼저 검사하고 조건식이 참인 동안 실행문을 반복합니다. 예를 들어 a가 10보다 작은 동안 두 배씩 반복적으로 늘리는 구문을 다음과 같이 작성할 수 있습니다.
```c
while (a < 10) // 조건식
{
    a = a * 2; // 실행문
}
```
```c
#include <stdio.h>

int main(void)
{
    int a = 1;

    while (a < 10)
    {
        a = a * 2;
    }
    printf("a : %d\n", a);

    return 0;

}
```
#### *컴파일러는 반복문의 조건식과 실행문을 모두 한 문장으로 인식합니다.
```c
if (a != 0)
    while (a<10)
    {
        a = a * 2
        printf("a의 값 : %d\n", a);
    }
```
if문에서와 비슷하게 컴파일러는 반복문의 조건식과 실행문을 모두 포함해 힌 문장으로 인식합니다. 따라서 만약 if문의 실행문이 반복문 하나로 되어 있다면 if문의 중괄호를 생략할 수 있습니다. 다만, 명확한 구분을 위해 기본적으로 중괄호를 사용하는 편이 좋습니다.
 ## for문
 while문과 비슷하게 for문도 반복문입니다. 다만, for문은 실행문을 원하느 횟수만큼 반복할 때 사용합니다. 예를들어 a값을 두 배로 증가시키는 문장을 세 번 반복하는 코드를 for문으로 작성하면 다음과 같습니다.
```c
for (i = 0, i < 3, i++)
{
    a = a * 2;
}
```

for문은 초기식, 조건식, 증감식으로 반복 횟수를 제어하면 블록 안의 문장을 반복합니다. 자세한 실행 과정은 예제를 통해 살펴보겠습니다.

#### 예제
```c
#include <stdio.h>

int main(void)
{
    int a = 1;
    int i;

    for (i = 0; i < 3; i++) //i는 0으로 초기화된 후에 3보다 작은 동안(i<3) 하나씩 증가하면서(i++)
    {
        a = a * 2;
    }
    printf("a : %d\n", a);

    return 0;

}
```
특정 횟수 만큼 반복하는 초기식, 조건식, 증감식의 조합은 많습니다. 예를 들어 다음은 모두 세번 반복하는 for문 입니다.
```c
for(i = 0; i < 3; i++)
for(i = 2; i <= 4; i++)
for(i = 0; i < 7; i +=3) // i값이 0,3,6일 때 세 번 반복
for(i = 3; i > 0; i--)
```
대부분 첫번째 형식을 많이 사용하긴 한다.

## for문 경로
i = 0(초기식) -> i < 3(조건식) -참-> a = a*2(실행문) -> i++(증감식) -> i = 0(초기식)
(조건식이 거짓이 될 때 탈출) 

*for문을 while문으로 바꿀 수 있나요?*
for문
```c
for (i = 0; i < 10; i++)
{
    printf("Be Happy!\n");
}
```
while문
```c
while (i < 10)
{
    printf("Be Happy!\n");
    i++;
}
```
## do ~ while문
while문, for문은 조건식을 먼저 확인하는 반면, do ~ while문은 일단 반복할 문장을 수행한 후에 조건을 검사합니다. 예를 들어 a값이 10보다 작은 동안 두 배씩 늘리는 문장을 do ~ while문으로 작성하면 다음과 같습니다. *do->while->do*
```c
do
{
    a = a * 2; //반복할 문장
} while (a < 10); //반복할 조건
```
do ~ while을 사용한 반복문 예제
```c
#include <stdio.h>

int main(void)
{
    int a = 1; //변수를 선언하고 1로 초기화
    do //  반복문 시작 위치
    {
        a = a * 2;
    } while (a < 10);
    printf("%d\n", a);

    return 0;
}
```
위의 코드를 while문으로 작성해도 결과는 같습니다. 그러나 a가 10으로 초기화되었다면 while문과 do ~ while문의 결과는 달라집니다. do ~ while문은 일단 먼저 실행하고 조건문으로 넘어가기에 결과값은 10에 2를 곱한 걸 먼저 실행시킨 20이 추출됩니다. 따라서 반복 조건을 검사하는 위치에 맞게 while문과 do ~ while문을 적절히 사용해야 합니다.

do ~ while문도 다른 반복문과 마찬가지로 반복할 문장이 한 문장이면 중괄호를 생략할 수 있습니다.

중괄호가 있는 코드
```c
do
{
    a = a * 2;
} while (a < 10);
```
중괄호가 없는 코드
```c
do a = a * 2; while (a < 10);
```
다만, 반복부분을 알기 쉽도록 중괄호를 사용하고 들여쓰기하는 것이 좋습니다. 그리고 do ~ while문 마지막에 붙어 있는 세미콜론(;)을 반드시 기억합시다. 세미콜론을 빠뜨렸는데 이를 인지 못하고 에러를 잡기 위해 엄한 곳을 들여다보는 경우가 꽤 발생합니다.
## do ~ while문의 특징
do ~ while문은 조건식과 관계없이 반복할 문장을 최소한 한 번은 실행합니다. while문은 조건을 만족해야지 실행문을 실행하므로 조건식이 거짓이면 실행문을 한 번도 실행하지 않고 바로 반복문을 빠져나갑니다.

## 반복문 마무리
#### while문은 반복 문장을 실행하기 전에 반복 조건을 먼저 검사한다.
#### for문은 반복 횟수가 정해진 경우에 사용하면 편리하다.
#### do ~ while문은 반복 문장을 실행한 후에 반복 조건을 검사한다.

while (조건식)
{
    실행문;
}

for(초기식; 조건식; 증감식)
{
    실행문;
}

do
{
    실행문;
} while (조건식);

## 중첩 반복문
중첩 반복문은 반복문 안에 실행할 문장으로 반복문이 포함된 것입니다. 앞서 언급했던 별을 다시 예로 들어 설명해 보겠습니다.
1 별 5개를 그린다
2 1을 세 번 반복한다.
 이 방식은 "단순한 반복문"입니다. 그런데 여기서 별 5개를 그린다는 것 또한 반복인 것을 알 수 있습니다.
 별 1개를 그린다
 2 1을 다섯번 반복한다
 3 2를 세 번 반복한다

 이러면 *중첩 반복문*입니다. 중첩 반복문의 실행과정을 이해하기는 쉽지 않습니다. 예제 코들르 통해 실행 순서를 하나씩 따라가면서 실행결과를 예상해 보겠습니다. 

```c
#include <stdio.h>

int main(void)
{
    int i, j;
    
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 5; j++)
        {
            printf("*");
        }
        printf("\n");
    }
    return 0;
}
```
실행결과
```c
*****
*****
*****
```
중첩 반복문을 이해하는 가장 좋은 방법은 반복과정에서 변하는 변숫값과 실행 문장을 확인하는 것입니다.
중첩 반복문 에서는 각 반복문이 서로 독립적인 제어 변수를 사용해야 각각 원하는 횟수를 반복할 수 있습니다. 다음 코드의 실행 결과를 예상하며 정말 그런지 확인해 보겠습니다.
```c
for (i = 0, i < 3; i++) //1번 for문
{
    for (i = 0; i < 5; i++) //2번 for문
    {
        printf("*");
    }
    printf("\n");
}
```
이 코드를 컴파일하면 동일하게 병 5개가 3줄 출력될까요? 아닙니다. 별은 다섯 번만 출력됩니다.
1번 for문의 제어 변수와 2번 for문의 제어 변수가 같으므로 2번 for문의 반복이 끝났을 때 i는 5가 됩니다. 이후 다시 바깥쪽 1번 for문의 증감식으로 올라가 i값이 6으로 증가한 후 조건 검사를 하면 곧바로 거짓이 되어 반복을 끝내게 됩니다.
## 중첩 반복문으로 구구단을 출력하는 프로그램
구구단을 출력하는 과정을 한 단계씩 만들어 가면서 중첩 빈복문을 작성하는 방법을 살펴보겠습니다.
미리 힌트를 주자면 중첩 반복문을 쓸 때에는 반복되는 기본 문장과 기본 규칙을 찾는 것이 제일 중요합니다.

구구단은 단의 수가 2단부터 9단까지 8개이므로 일단 1개의 단을 출력하는 코드를만들고 그 코드를 여덟번 반복하면 됩니다.

권태양이 짠 코드
```c
#include <stdio.h>

int main(void)
{
    int i, j, a;
    i * j = a;
    for (i = 2; i < 10; i++)
    {
        for ( j = 1, j < 10; j++)
        {
            printf("%d * %d = %d\n", i, j, a);
        }
    }

    return 0;
}
```

정답
```c
for ( i = 2; i <= 9; i++)
{
    for (j = 1; j <= 9; j++)
    {
        printf("%d * %d = %d\n", i, j, i * j);
    }
}
```
문제점 오답노트
###### *i * j = a; 문법 오류*
C언어에서 i * j = a;는 의미가 없어요.
*는 곱셈 연산자이지, 변수 선언할 때 쓰는 게 아니고, 곱셈 결과에 값을 대입할 수도 없습니다.
아마도 a = i * j;로 하려고 했던 것 같습니다.
###### *for 문 조건부에 , 사용*
for ( j = 1, j < 10; j++)
여기서 ,는 콤마 연산자라, 실제로는 첫 번째 식 j = 1만 실행되고 j < 10은 무시됩니다.
, 대신 ;를 써야 합니다.
즉, for ( j = 1; j < 10; j++)
###### *곱셈 결과를 출력하기 전에 계산 안 함*
a 값은 i와 j의 곱을 저장해야 하므로, 내부에서 a = i * j;를 해야 합니다.
#### *내부에서 해야하는 이유*
###### *a 값은 i와 j의 곱을 담는 변수*
i와 j는 for문이 돌면서 계속 변하는 값이에요.
예를 들어,
첫 번째 반복: i = 2, j = 1 → 곱은 2
두 번째 반복: i = 2, j = 2 → 곱은 4
매 반복마다 다른 값이 나오니까, 매번 새로 계산해야 합니다.
###### *내부에서 안 하면 생기는 문제*
만약 a = i * j;를 for문 밖에 둔다면,
그 순간에 i와 j가 딱 한 번만 계산되고,
그 후로는 a 값이 그대로 유지되어 구구단 전체가 같은 결과를 찍게 됩니다.

#### 내가 했던 오답을 정답으로 고친 것
```c
#include <stdio.h>

int main(void)
{
    int i, j, a;

    for (i = 2; i < 10; i++)
    {
        for (j = 1; j < 10; j++)
        {
            a = i * j; // 곱셈 결과 저장
            printf("%d * %d = %d\n", i, j, a);
        }
    }

    return 0;
}
```
## break와 continue 분기문
#### break
break는 반복문 안에서 반복을 즉시 끝낼 때 사용합니다. 모든 반복문은 조건식이 거짓일 때 반복이 끝납니다. 따라서 반복문 처음에 조건식이 있는 while문이나 for문은 반복문 위에서 반복이 끝나고 마지막에 조건식이 있는 do~while문은 반복문 밑에서 반복이 끝납니다. 그런데 예외적으로 반복문 중간에서 임의로 반복을 끝내고 싶을 때는 break를 사용합니다. if (조건식) break;
#### break를 사용한 반복문 종료
```c
#include <stdio.h>

int main(void)
{
    int i;
    int sum = 0;

    for (i = 1; i <= 10; i++)
    {
        sum += i;
        if (sum > 30) break;
    }

    printf("누적한 값 : %d\n", sum);
    printf("마지막으로 더한 값 : %d\n", i);

    return 0;

}
```
#### break로 무한 반복문 빠져 나오기
반복문의 조건식이 항상 참이면 무한 반복문이 됩니다.
```c
while(1) //1은 참을 의미.
{
    printf("Be happy!\n");
}
```
조건식에 사용된 1은 참을 의미하며 반복 과정에서 변하지 않으므로 출력문은 무한 반복 됩니다. for문으 사용할 때는 괄호 안에 세미콜론을 2개 사용합니다.
```c
for (;;)
{
    printf("Be happy!\n");
}
```
무한 반복문은 기본적으로 무한히 반복되므로 반복을 끝낼 때에는 조건에 따라 break를 사용합니다.

```c
count = 0;
while (1)
{
    printf("Be happy!\n");
    count++;
    if (count == 5) break;
}
```
##### ***if문과 달리 switch ~ case문의 블록 안에서 break를 사용하면 switch~case 블록만 벗어납니다***

#### continue
continue는 반복문의 일부를 건너뜁니다. 반복문 안에서 continue를 사용하면 다음 살행 위치가 반복문의 블록 끝이 됩니다. 블록을 탈출하는 것은 아닙니다. 따라서 조건에 따라 반복문의 일부를 제외하고 반복할 수 있습니다. 예를 들어 3의 배수를 빼고 1부터 100까지의 합을 구할 때 효과적으로 사용할 수 있습니다.
```c
for (i = 1; i <= 100; i++)
{
    if ( (i % 3) == 0)
    {
        continue; // i가 3의 배수면 sum += i 문장을 건너뛰고 블록 끝으로 간 후에 다시 반복합니다.
    }
    sum += i;
}
```
continue에 의해서 제어가 블록의 끝으로 이동한 후에는 다시 반복이 시작됩니다. 결국 다음 실행 위치는 증감식이 됩니다.

#### while문에서 continue 사용 시 유의점
for문과 달리 while문에서 continue를 사용하면 다음 실행 위치가 조건식이 됩니다,. 만약 위의 for문을 다음과 같이 while문으로 바꾸면 증감식이 실행되지 않으므로 무한 반복됩니다.
```c
i = 1;
while (i <= 100)
{
    if ((i % 3) == 0 )
    {
        continue; // i가 3일 때 증감식 i++를 건너뛰므로 while문의 조건식은 계속 참이 됩니다.
    }
    sum += 1;
    i++;
}
```
#### GPT한테 물어본 while문에서 continue 사용법
좋은 잘문이에요. while문 안에서 **continue**는 이번 반복을 건너뛰고 바로 다음 반복으로 넘어가라는 뜻이에요.
#### 예시 1: 짝수만 출력하기

```c
#include <stdio.h>
int main(void)
{
    int i = 0;

    while (i < 10)
    {
        i++; //i를 1증가
        
        if (i % 2 == 1) //홀수일 때 밑에 코드 무시하고 while 처음으로
        {
            continue;
        }
        printf("%d\n", i); //짝수만 출력됨
    }
    return 0;
}
```
#### i가 홀수면 -> continue 실행 -> printf 건너뜀
#### i가 짝수면 -> continue 안열림 -> printf 실행 

#### 예시 2 : 특정 값만 건너뛰기
```c
#include <stdio.h>
int main(void)
{
    int i = 0;
    while (i < 5)
    {
        i++;
        if(i == 3)
        {
            continue; // i가 3일 때만 출력 생략
        }
        printf("%d\n", i);
    }
    return 0;
}
```
-> i == 3 일 때 continue 때문에 출력하지 않고 바로 반복문 처음으로 넘어감.

#### 정리하면
continue; -> 아래 코드를 무시하고 반복문의 처음으로 돌아감. while에서는 continue 실행시 -> 조건 검사(while(조건))로 바로 이동

# 함수
함수란 기능을 수행하는 코드 단위를 말합니다. 지금까지 사용해 왔던 main 함수가 대표적인 함수 입니다. 그리고 printf와 scanf도 함수입니다. printf마 scanf함수처럼 특정 기능을 미리 약속하고 프로그램에서 바로 사용할 수 있게 구현되어 있는 함수를 "표준 라이브러리 함수"라고 합니다. printf나 scanf함수는 모든 예제에 있던 stdio.h 헤더 파일에 포함되어 있습니다.

#### 이처럼 C언어에서 표준으로 제공하는 함수 외에도 자주 사용하는 코드를 함수로 만들어 필요할 때 사용할 수도 있습니다. 함수를 만들려면 다음의 3가지가 중요합니다.
함수 정의 : 함수를 실제 코드로 만드는 것으로 함수의 기능을 구현 합니다.
함수 호출 : 함수 호출을 해야지 함수를 사용할 수 있습니다.
함수 선언 : 프로그램의 상단에서 어떤 함수를 사용할 것이라고 컴파일러에 정보를 주는 역할을 합니다.

#### 예를 들어 두 정수의 합을 자주 계산하는 경우 해당 기능을 함수로 만들면 필요할 때 호출만 하면 되므로 편리 합니다.

## 새로운 함수를 만드는 방법도 main 함수를 만드는 방법과 크게 다르지 않습니다. 다만, 함수를 만들기 전에 다음 3가지를 먼저 생각해 보겠습니다.

#### 1 함수의 기능에 맞는 이름은 무엇인가?
#### 2 함수가 기능을 수행할 때 필요한 데이터는 무엇인가?
#### 3 함수가 수행된 후의 결과는 무엇인가?

#### 이 3가지에 맞춰서 다시 두 정수의 합을 구하는 함수를 만든다고 가정해 보겠습니다.
이 3 가지에 맞춰서 다시 두 정수의 합을 구하는 함수를 만든다고 가정해 보겠습니다.
#### 
#### 1 함수의 기능에 맞는 이름은 무엇인가? //함수명
-> 구현하려는 기능 = 더하기 = 영어로는 sum
#### 2 함수가 기능을 수행하는 데 필요한 데이터는 무엇인가? //매개변수
-> 더하려는 정수
#### 3 함수가 수행된 후의 결과는 무엇인가? //반환형
-> 정수(정수 2개를 더한 값은 정수)

####간단하게 답한 이 질문이 바로 함수 원형(function prototype)을 이룹니다. 이 내용을 코드 형식으로 쓰면 다음과 같습니다.
```c
###### 함수 정의
###### 반환형 함수명(매개변수1, 매개변수2)
###### {
###### //함수가 수행하는 명령. 결괏값(매개변수1 + 매개변수2)을 돌려보냄
###### }
```
## 2개의 함수로 만든 프로그램
```c
#include <stdio.h>

int sum(int x, int y); //sum 함수 선언

int main(void) //main 함수 시작
{
    int a = 10, b = 20;
    int result; // 두 정수를 더한 결과(result)를 저장할 변수

    result = sum(a,b); //sum 함수 호출
    printf("result : %d\n", result);

    return 0;
} // main 함수의 끝
 
 int sum(int x, int y) //sum 함수 정의 시작
 {
    int temp; // 두 정수의 합을 잠시 저장할 변수

    temp = x + y; // x와 y의 합을 temp에 보관

    return temp; //temp의 값을 변환
 } //sum 함수의 끝
 ```
우선 함수를 만드는 함수 정의 위치부터 살펴봅시다. 함수를 다른 함수 안에서 정의할 수는 없습니다. 따라서 sum 함수는 main함수와 별도의 구역(16~23행)에 만듭니다. 함수를 만들 때는 함수의 원형을 먼저 작성합니다. 16행이 함수 원형을 만드는 부분이며 여기서 반환형, 함수명, 매개변수를 표시합니다.
#### int[반환형] sum[함수명](int x, int y)[매개변수] // 16행 함수 원형

#### ***cf***반환형
반환형은 함수가 기능을 수행한 후 호출한 곳으로 돌려줄 값의 자료형을 적습니다. 즉 sum함수는 두 정수의 합을 반환해야하므로 자료형으로 int를 사용합니다.
```c
int sum(int x, int y)
{
    int temp; // ~

    temp = x + y; // 

    return temp; // ~ 실제 함수의 내용 함수가 수행하는 명령
}
```
함수 내에서 필요한 변수가 있다면 18행과 같이 별도로 선언합니다.
 ```c
 int temp; //18행. 두 정수의 합을 잠시 저장할 변수
```
매개변수의 합을 더해서 변수 temp에 잠시 저장했다가 return문에서 변수 temp에 저장해 두었던 값을, 함수를 호출한 곳으로 반환합니다. 여기서 temp는 기능상 꼭 필요한 변수가 아니므로 return (x +y);과 같이 두 수의 합을 바로 반환하는 것도 가능합니다.
// return은 함수의 실행결과를 돌려주는 제어문입니다.

#### temp에 두 수의 합을 저장하는 코드
```c
int sum(int x + int y)
{
    int temp;

    temp = x + y;

    return temp;
}
```
#### temp가 없는 코드
```c
int sum(int x, int y)
{
    return (x + y); //두 수의 합을 바로 반환
}
```
#### 함수 속 변수명
함수에서 사용하는 변수명에 관해 잠깐 생각해 봅시다. 함수 안에서 사용하는  변수명은 다른 함수의 변수명과 같아도 됩니다. 다시 말해, sum의 함수의 변수명을 main 함수의 변수명과 같은 이름으로 선언할 수 있습니다.
```c
int sum(int a, int b) //매개변수 a,b는 main함수의 변수와 이름이 같음
{
    int result; //main 함수에도 result 변수명이 있음.

    result = a + b; // a,b는 main함수의 a,b가 아니고 매개변수 a,b를 말함.

     return result;
}
```
#### 왜 그럴까?
***컴파일러는 변수명의 사용 범위를 선언한 블록 내부를 제한합니다.*** 따라서 둘 이상의 함수에서 같은 이름의 변수를 선언해도 중복에러가 발생하지 않습니다. 이 경우 각 변수는 함수별로 독립된 저장 공간을 가지며 함수 내에서만 사용할 수 있습니다.

## 함수 호출
지금까지 함수를 만들어 봤습니다. 함수는 얼마든지 만들 수 있지만, 만든 함수가 모두 자동으로 실행되는 것은 아닙니다. 함수를 사용하려면 먼저 함수 호출을 해야합니다. 

#### 함수를 호출할 때에는 이름을 사용하며 함수에 필요한 데이터를 괄호 안에 넣어 주는데, 이를 "인수"라고 합니다.
sum 함수를 호출해서 a와 b를 더하려면 함수명과 함께 괄호 안에 a,b를 넣고 호출합니다. 인수는 상수나 변수를 쓸 수 있고 수식을 사용하면 수식의 결괏값이 인수로 쓰입니다.
#### sum[함수명](30, 40)[상수 인수], sum[함수명](a*2, b/3)[수식 인수]
함수를 호출할 때 이렇게 입력된 인수 a,b의 값은 호출된 함수의 매개변수에 복사되어 사용됩니다. 다시 코드를 보면 sum 함수가 호출되면 main함수의 실행은 잠시 멈추고 비로소 sum 함수 정의 부분에 있는 코드가 실행됩니다. 이때 인수는 함수의 매개변수에 순서대로 복사되어 sum 함수 안에서 사용됩니다. 

## 함수 반환
호출된 함수의 실행이 끝나고 값을 반환할 때 return문을 사용합니다. 다음 코드를 보면 sum함수는 x와 y를 더하고 그 값을 temp에 저장한 뒤 함수의 실행을 끝내고 호출한 곳으로 돌아가기 위해 return문을 사용합니다. 이때 temp의 값을 호출한 곳으로 반환합니다. 이후 main 함수는 반환된 값을 대입 연산으로 result에 저장하고 잠시 중단했던 함수의 나머지 부분을 실행합니다.

## 함수 선언
함수 선언은 컴파일러가 새로 만든 함수를 인식할 수 있도록 알리는 역할을 합니다.
#### int[반환형] sum[함수명](int x, int y)[매개변수];
선언 방법은 간단합니다. 세미콜론을 붙이면 됩니다. 함수 선언은 main함수 앞에 하며 다음처럼 매개변수 이름은 생략할 수 있습니다.
```c
int sum(int, int) //매개변수 이름을 생략한 형태
```
그런데 엄연히 함수 정의가 있는데 왜 함수 선언이 필요할까요?
#### 이유 1 함수 선언에서 반환값의 형태를 확인합니다.
컴파일러는 컴파일할 때 함수를 호출한 자리에 반환값과 같은 형태의 저장 공간을 준비합니다. 즉, 정수를 반환하면 호출한 자리에 int형 공간을 확보하고 실수를 반환하면 double형 공간을 확보합니다. 따라서 함수를 호출하기 전에 선언을 통해 반환형을 미리 컴파일러에 알릴 필요가 있습니다. 물론 함수 정의에서도 반환형을 확인할 수 있으므로 함수 호출 이전에 함수를 정의하는 방법도 있습니다.

#### main 함수 앞에 sum 함수를 정의하면 함수 정의에 원형이 포함되므로 따로 함수를 선언할 필요가 없습니다. 코드를 방금 설명한 순서로 바꿔도 실행 순서는 변하지 않습니다. 프로그램은 항상 main 함수부터 시작하며 그 이후에는 호출 순서에 따라 실행되기 때문입니다.

### ***cf***함수 선언이 없으면 함수 정의는 항상 함수 호출 이전에 있어야 합니다.
함수를 미리 선언하지 않으려면 항상 호출하는 함수 앞에 정의해야합니다. 이때 여러 함수 간에 호출 관계가 엉켜있다면 순서에 맞게 정의하는 일이 쉽지 않습니다. 따라서 필요한 함수를 main함수 밑에 차례로 만들고 main함수 앞에는 모든 함수를 선언해 함수의 종류와 원형을 한눈에 파악하고 자유롭게 호출할 수 있도록 작성하는 것이 좋습니다. 또한 분할 컴파일하는 프로그램에서 호출하는 함수와 호출되는 함수가 서로 다른 파일에 있으면 반드시 선언이 필요합니다.

### 함수의 호출 형식에 문제가 없는지 검사합니다. 
함수 선언문에는 매개변수의 개수와 형태에 대한 정보가 있으므로 호출할 때 정확한 값을 주는지 검사할 수 있습니다. 예를 들어 sum 함수에 필요한 값이 정수 2개인데 인수로 실수를 주고 호출하면 컴파일 단계에서 확인하고 경고 메시지로 문제점을 알려 줍니다.
 
 ## 여러 가지 함수 유형
 함수 원형은 반환형 함수명(매개변수)로 이루어진다고 배웠습니다. ***하지만 언제나 함수에 반환형과 매개변수가 있는 것은 아닙니다.*** 앞의 sum함수는 두 수를 더하는 함수였기에 매개변수가 필요했습니다. 그런데 단순히 키보드 값을 확인하고 양수를 반환하는 함수라면 어떨까요? 이때는 매개변수가 필요 없습니다. scanf함수로 바로 입력을 받으면 될 테니까요.

 #### 매개변수가 없는 함수
 ```c
 #include <stdio.h>

 int get_num(void); //함수 선언

 int main(void)
{
    int result;
    
    result = get_num(); //함수 호출, 반환값은 result에 저장, get_num 함수는 매개변수가 없습니다. 당연히 호출할 때 인수가 없습니다. 그렇다면 get_num으로 적어도 될까요? 아니면 get_num(void)로 적어야 할까요? 둘 다 아닙니다. void는 함수 정의나 선언에서 적용되며 호출할 때는 쓰지 않습니다. 그냥 괄호만 쓰면 됩니다. 괄호 조차 없다면 함수를 호출하는 문장이 아닌 그냥 함수의 이름으로 인식하므로 반드시 괄호는 사용해야 합니다.
    printf("반환값 : %d\n", result); //반환값 출력
    return 0;
}

int get_num(void) //매개변수가 없고 반환형만 있다.
{
    int num; //키보드 입력값을 저장할 변수

    printf("양수 입력 : "); //입력 안내 메시지
    scanf("%d\n", &num); //키보드 입력

    return num; //입력한 값 변환
}
```
괄호 안에 void를 넣어 매개변수가 없음을 표시합니다. 괄호만 사용해도 매개변수가 없다는 사실을 표시할 수 있지만, void를 넣어 매개변수가 없음을 명시적으로 표현하는 것이 좋습니다. get_num 함수는 매개변수가 필요 없지만, 키보드로 입력받은 값을 호출 함수로 반환하므로 반환형(int)은 있어야 합니다. 또한 반환하는 문장 return num;도 필요합니다.

## 음수 입력에 대응합시다
get_num 함수는 양수를 입력받아 반환하는 작업을 처리합니다. 더 욕심을 부려 음수가 입력될 때 경고 메시지를 출력하고 다시 입력 받도록 수정해보겠습니다.
```c
int get_num(void)
{
    int num;
    printf("양수 입력 : \n");
    scanf("%d", &num);
    while (num < 0)
    {
        printf("양수를 입력하세요!\n");
        printf("양수 입력 : \n");
        scanf("%d", &num);
    }
    return num;
}
```
이처럼 프로그램을 실행하다가 발생할 수 있는 예외 상황에 대비해 코드를 추가하는 것이 바로 ***예외 처리*** 입니다.

## 반환값이 없는 함수
함수는 기능에 따라 형태가 결정됩니다. 데이터를 받아서 단지 화면에 출력하는 함수라면 반환값이 필요 없습니다.
#### 예를 들어 문자와 숫자를 인수로 받으면 문자를 숫자만큼 화면에 출력하는 함수를 생각해 보겠습니다. 화면에 출력한 내용이 함수가 수행한 결과이므로 호출한 곳으로 특별히 값을 반환할 필요가 없습니다. 매개변수의 빈자리에 void를 사용했던 것처럼 반환형의 자리에 void를 사용했던 것처럼 반환형의 자리에 void를 사용합니다.
```c
#include <stdio.h>

void print_char(char ch, int count); //함수 선언

int main(void)
{
    print_char('@',5); //문자와 숫자를 두고 함수 호출

    return 0;
}

void print_char(char ch, int count) //매개변수는 있으나 반환형은 없다.
{
    int i;

    for (i = 0; i < count; i++) //i는 0부터 count-1까지 증가, count번 반복
    {
        printf("%c", ch); //매개변수 ch에 받은 문자 출력
    }
    return;
}
```
문자와 숫자를 받아야 하므로 매개변수는 있으나 반환형은 void를 사용합니다.
또한 반환값이 없으므로 return문은 값 없이 단독으로 사용합니다.
#### return의 역할이 값을 돌려주는 일인데, 돌려줄 값이 없으므로 자연스럽게 혼자 쓰입니다. 심지어 retrun문 자체를 생략하는 것도 가능합니다. return 문이 없어도 함수의 코드를 모두 수행하면 호출한 곳으로 자동으로 돌아갑니다.

만약 함수 실행 중간에 돌아가야 한다면 return문을 함수 어디서든 사용할 수 있습니다. 예를 들어 count의 값이 10보다 큰 경우 바로 함수를 끝내고 싶다면 다음과 같이 함수 중간에 return문을 사용하면 됩니다. 이때도 return문만 단독으로 사용합니다.
```c
void print_char(char ch, int count)
{
    int i;
    if (count > 10) return; //여기서 return하면 함수의 실행을 종료한다
    for (i = 0; i < count; i++)
    {
        printf("%c",ch);
    }
    return;
}
```

## 매개변수와 반환값이 모두 없는 함수
매개변수와 반환값이 모두 없는 함수도 있습니다. 예를 들어 일정한 문자열을 여러 번 출력하는 함수라면 매개변수와 반환값이 모두 필요 없습니다. 이때는 함수의 매개변수와 반환형에 모두 void를 씁니다. 반환값과 매개변수가 모두 없는 함수를 단단히 만들어 살펴보겠습니다.

```c
#include <stdio.h>

void print_line(void);

int main(void)
{
    print_line();
    printf("학번    이름    전공    학점\n");
    print_line();
    
    return 0;
}
void print_line(void)
{
    int i;
    
    for (i = 0; i < 50; i++)
    {
        printf("-");
    }
    printf("\n");
}
```
## 재귀호출 함수
함수는 보통 다른 함수를 호출하는데 재귀호출 함수는 자기 자신을 호출합니다는 어렵지만 만들기는 쉽습니다. 우선 간단하게 apple을 출력하는 재귀호출 함수부터 살펴보겠습니다.
```c
#include <stdio.h>

void fruit(void); //함수 선언

int main(void)
{
    fruit(); // 함수 호출

    retrun 0;
}

void fruit(void) //재귀호출 함수 정의
{
    printf("apple\n");
    fruit(); // 자신을 다시 호출
}
```
#### ***왜 무한으로 apple을 출력하지 않고 종료할까요?***
함수는 호출만으로도 일정 크기의 메모리를 사용하므로 프로그램 하나가 쓸 수있는 메모리(해당 프로세스에 할당된 스택 메모리)를 모두 사용하게 되어 메모리부족으로 강제 종료됩니다. 따라서 컴파일러는 컴파일 과정에서 경고메시지를 띄워 알려줍니다.

### 세 번 실행되는 재귀호출 함수
```c
#include <stdio.h>

void fruit(int count);

int main(void)
{
    fruit(1);
    
    return 0;
}

void fruit(int count) //호출 횟수를 매개변수에 저장
{
    printf("apple\n");
    if (count == 3) return; //호출 횟수가 3이면 반환하고 끝낸다.
    fruit(count + 1); // 재호출할 때 호출 횟수를 1 증가
}
```
### 재귀호출과 반복문의 차이점
여기까지 잘 따라왔다면 '재귀 호출 대신 그냥 반복문을 사용해도 되지 않을까?'라는 의구심이 들겁니다. 재귀 호출과 반복문은 어떤 차이가 있는지 에제로 살펴보겠습니다.
```c
#include <stdio.h>

void fruit (int count);

int main(void)
{
    fruit(1);

    return 0;
}

void fruit (int count)
{
    printf("apple\n");
    if (count == 3 ) return; //15행
    fruit(count + 1);
    print("jam\n"); //17행
}
```
재귀호출 이후 17행에 출력문을 하나 더 넣었습니다. 15행의 return문이 최초 호출한 main함수로 돌아간다면 17행은 절대 실행되지 않을 겁니다. 그러나 예상과 달리 실행결과를 보면 17행이 실행되어 jam이 두번 출력되었습니다.
#### 왜 그럴까요? 재귀호출 함수의 경우 최초 호출한 곳이 아니라 이전에 호출했던 곳으로 돌아갑니다. 이 상황은 재귀 호출이 수행될 때마다 함수의 복사본을 만들어 보면 쉽게 이해할 수 있습니다.

# 배열
## 배열의 선언과 사용
지금까지 메모리에 저장 공간을 확보할 때 변수를 선언했습니다. 예를 들어 다섯 과목의 점수를 처리 하고싶어서 다음과 같이 점수를 int형 변수로 하나씩 개별적으로 선언했다고 가정합시다.
#### int kor, math, eng, social, science;
이렇게 하나씩 따로따로 선언하면 점수도 일일이 하나씩 변수에 넣어주어야 합니다. 즉, 반복문 사용이 불가능합니다. 왜냐하면 이름이 별도로 있기 때문입니다. 그래서 우리는 같은 형태의 많은 데이타를 반복문으로 처리하기 위해서 메모리에 연속적으로 저장해 놓고 쪼개서 사용하는 방법을 사용합니다. 이를 "배열"이라고 합니다.

## 배열의 선언
배열 또한 다른 자료형처럼 선언을 통해서 저장 공간을 확보합니다. 다만, 다섯 과목의 점수를 처리할 때 기존처럼 int형 변수를 하나씩 선언하지 않고, 하나의 이름으로 한꺼번에 확보합니다. 또 저장 공간의 개수와 관계없이 이름은 하나만 사용합니다.
#### 배열을 선언하는 방법은 간단합니다. 요소의 자료형에 이름을 붙이고 필요한 요소의 개수를 표시합니다. 요소가 5개인 배열을 선언하는 예는 다음과 같습니다.
```c
int ary[5];
```
배열명은 변수명을 짓는 규칙에 따라 적절한 이름을 사용합니다. 배열을 하나 선언한 다음 5명의 나이를 저장하고 사용하는 방법을 예제로 확인해 보겠습니다.
```c
#include <stdio.h>

int main(void)
{
    int ary[5]; //int형 요소 5개의 배열 선언

    ary[0] = 10; //ary는 array의 축약어
    ary[1] = 20;
    ary[2] = ary[0] + ary[1];
    scanf("%d", &ary[3]);

    printf("%d\n", ary[2]);
    printf("%d\n", ary[3]);
    printf("%d\n", ary[4]); //마지막 배열 요소는 쓰레기값

    return 0;

}
```
int형 변수는 크기가 4바이트이므로 5개를 연속으로 할당하면 총 20바이트가 됩니다. 배열요소는 배열명에 첨자(index)를 붙여 표현하며 첨자는 0부터 시작합니다.

## 배열 초기화
배열도 변수와 마찬가지로 최초할당된 저장 공간에는 쓰레기 값이 저장되어 있습니다. 그러므로 배열도 원하는 값을 가지려면 선언과 동시에 초기화해야 합니다. 배열은 중괄호({})로 묶어서 초기화합니다.
#### 기본적인 초기화 방법입니다.
```c
int ary[5] = {1,2,3,4,5};
```
초깃값은 첫 번째 요소부터 차례로 초기화됩니다.
#### 초깃값이 배열의 요소의 개수보다 적은 경우입니다.
```c
int ary[5] = {1,2,3};
```
이때는 왼쪽부터 차례로 초기화하고 남은 배열 요소느 모두 0으로 채웁니다. ary[0]부터 ary[2]까지 각 1,2,3이고 ary[3], [4]는 모두 0.
#### 자동 초기화 기능을 사용할 수도 있습니다.
```c
int ary[1000] = {0};
```
이러면 배열 요소 개수가 아무리 많아도 모든 요소를 쉽게 0으로 초기화할 수 있습니다.
#### 배열 요소 개수가 생략된 형태도 있습니다.
```c
int ary[] = {1,2,3};
```
이 경우 컴파일러는 초깃값 개수만큼 배열 요소 개수를 정하고 저장공간을 할당 합니다. 즉, 다음과 같은 메모리에 저장공간이 할당되고 초기화 됩니다.
#### ary[0] = 1, ary[1] = 2, ary[2] = 3
#### double형 배열과 char형 배열을 선언하고 초기화 합니다. 각각의 자료형에 맞게 double형 배열은 실수 값으로 초기화되고, char형 배열은 문자로 초기화 됩니다.
#### double ary[5] = {1.0, 2.1, 3.2, 4.3, 5.4};
#### char ary[5] = {'a','p','p','l','e'};
char형 배열은 주로 문자열을 저장하는 용도로 사용된다.
#### 배열의 초기화는 선언시 최초 한 번만 가능합니다. 그 이후에는 배열 요소에 일일이 값을 대입해야 하며, 초기화 때처럼 중괄호({})를 사용한 대입 연산으로 한 번에 값을 바꾸는 것은 불가능합니다.

## 배열과 반복문
연속된 저장공간을 할당하고 초기화할 수 있어 같은 유형의 변수가 많이 필요할 때 배열을 사용한다고 했습니다. 이렇게 연속된 배열 요소를 일일이 변수처럼 하나씩 떼어서 사용한다면, 이는 배열을 제대로 활용하고 있지 못한 것입니다. 배열 요소가 5개인 배열에 정수를 입력하는 다음 예시를 볼까요?
```c
int score[5];

scanf("%d", &score[0]);
scanf("%d", &score[1]);
scanf("%d", &score[2]);
scanf("%d", &score[3]);
scanf("%d", &score[4]);
```
언뜻 봐도 같은 작업을 반복하고 있으며 바뀌는 것은 첨자 뿐입니다. 따라서 반복문을 사용하면 간단히 구현할 수 있습니다. 예제를 통해 확인해보겠습니다.
```c
#include <stdio.h>

int main(void)
{
int score[5];
int i;
int total = 0;
double avg;
for (i =0; i < 5; i++)
{
    scanf("%d", &score[i]);
}
for (i = 0; i < 5; i++)
{
    total += score[i];
}
avg = total / 5.0;

for (i = 0; i < 5; i++)
{
    printf("%d\n", score[i]);
}
printf("\n");

printf("평균 : %.1lf\n",avg);

return 0;
}
```

## sizeof 연산자를 활용한 배열 처리
보통 많은 양의 데이터를 처리하므로 배열을 다룰 때는 반복문 사용이 필수입니다. 따라서 배열 요소의 개수가 바뀌면 배열을 처리하는 반복문을 모두 수정해야하는 부담이 있습니다. 이 문제의 해결책으로 배열 요소의 개수를 직접 계산해 반복문에 사용하는 방법을 사용할 수 있습니다.

#### 배열 요소의 개수는 다음과 같이 구합니다.
```c
#### sizeof(배열명) / sizeof(배열 요소)
```
```c
#include <stdio.h>

int main(void)
{
    int score[5];
    int i;
    int total = 0;
    double avg;
    int count;

    count = sizeof(score) / sizeof(score[0]);

    for (i = 0; i < count; i++)
    {
        scanf("%d", &score[i]);
    }
    for (i =0; i < count; i++) // 11행에서 계산한 count만큼 반복
    {
        total += score[i];
    }
    avg = total / (double)count;

    for (i = 0; i < count; i++)
    {
        printf("%5d\n", score[i]);
    }
    printf("\n");

    printf("평균 : %.1lf\n", avg);
    
    return 0;
}
```
# 문자를 저장하는 배열
우리는 평소 의미를 전달하기 위해 단어를 사용합니다. 단어는 알파벳의 나열이며, 그 순서에 따라 단어의 뜻이 달라집니다. 이런 단어를 컴퓨터에서 데이터로 처리하려면 메모라에 문자를 순서에 맞게 연속으로 저장해야 합니다. 결국 배열이 단어를 저장하기 위한 가장 좋은 방법입니다. 그리고 모든 알파벳 문자는 한 바이트로 충분히 표현할 수 있으나 char형 배열을 사용하는 것아 좋습니다.

## char형 배열의 선언과 초기화
char형 배열을 선언할 때 꼭 기억해야 할 점은 저장할 문자열의 길이보다 최소한 하나 이상 크게 배열을 선언해야 한다는 것입니다..

#### 예를 들어 문자열 "apple"을 저장할 배열은 배열 요소 개수가 최소한 6개 이상이어야 합니다. 남는 공간이 하나 이상 있어야 합니다.
이렇게 여분의 공간이 필요한 이유는 널 문자(\0)을 사용하기 때문입니다. 널 문자의 기능은 다음 예제를 통해 확인해 보겠습니다.
```c
#include <stdio.h>

int main(void)
{
    char str[80] = "applejam"; //문자열 초기화

    printf("최초 문자열 : %s\n", str); //초기화 문자열 입력
    printf("문자열 입력 : ");
    scanf("%s", str); //새로운 문자열 입력
    printf("입력 후 문자열 : %s\n", str); //입력한 문자열 출력

    return 0;
}
```
char형 배열은 배열 요소의 형태가 char일 뿐 int형 배열이나 double형 배열과 다르지 않습니다. 따라서 초기화도 중괄호를 사용해 문자를 차례로 나열해도 됩니다. 그러나 다음 예시에서도 볼 수 있듯이 문자 상수로 초기화하는 방법은 쉽지 않으므로 문자열 상수로 초기화하는 방법을 많이 사용합니다.
#### ***문자 상수로 하나씩 초기화 char str[80] = {'a','p','p','l','e','j','a','m'};***
#### ***문자열 상수로 한 번에 초기화 char str[80] = "applejam";***

### 널 문자의 용도 
초기화한 문자는 배열의 처음부터 차례로 저장되어 문자열을 만듭니다. 이때 남는 배열 요소에는 자동으로 0이 채워집니다. 이렇게 char형 배열에 저장된 0을 특별히 널 문자라고 부릅니다.
#### 모든 문자는 아스키 코드 값으로 저장되므로 결국 널 문자는 아스키 코드 값이 0인 문자를 말하며 문자 상수로는 \0으로 표현됩니다.
str배열 a|p|p|l|e|j|a|m|\0|\0|\0|\0|---
#### 아스키 코드 값이 0인 문자를 널 문자라는 이름으로 특별히 대접하는 이유는, 널 문자가 문자열의 끝을 표시하는 용도로 쓰이기 때문입니다.
## "널 문자는 문자열의 끝을 표시한다.
7행의 printf함수가 배열의 크기와 관계없이 초기화된 문자열만을 정확히 출력하는 것도 널 문자가 있기 때문입니다. printf 함수는 char형 배열에서 널 문자가 나올 때까지만 출력하도록 만들어졌습니다. 이런 규칙은 문자열을 처리하는 모든 함수에 도움이 됩니다.
#### scanf 함수가 배열의 처음부터 grape만 입력했다면, 10행의 "입력 후 문자열 : " 다음 출력 결과는 grapejam이어야 합니다. 그러나 scanf함수는 사용자가 입력한 문자열 다음에 자동으로 널 문자를 추가해 문자열의 끝을 표시합니다. 따라서 10행의 print 함수는 grape까지만 출력합니다.
### "scanf 함수는 마지막 입력 문자 뒤에 자동으로 널 문자를 저장합니다.

## char형 배열 선언 시 주의할 점 
char형 배열을 선언할 때 주의할 점을 정리하고 넘어가겠습니다.
#### 주의 1 : 배열의 크기는 최대한 넉넉하게 선언해야 합니다.
문자열의 길이가 일정하지 않을 경우 예상 가능한 가장 긴 문자열도 저장할 수 있도록 넉넉히 선언해야 합니다.
#### 주의 2 : 배열 요소의 개수는 최소한 '문자열 길이 + 1'이어야 합니다.
널 문자로 그 끝을 표시하므로 최소한 널 문자까지 저장할 수 있도록 배열의 요소의 개수를 지정해야 합니다.

# 문자열 대입
char형 배열이 문자열을 저장하는 변수의 역할을 하므로 초기화된 이후에도 얼마든지 새로운 문자열을 저장할 수 있습니다. 단, 문자열의 길이가 다를 수 있으므로 일반 변수처럼 대입 연산자를 사용하는 것은 불가능합니다. 이때는 strcpy 함수를 사용합니다.
#### strcpy 함수는 char형 배열에 새로운 문자열을 저장하는 함수로, 저장할 문자열의 길이를 파악해 딱 그 길이만큼만 char형 배열에 문자열을 복사합니다. 물론 문자열 끝에 널 문자도 자동으로 붙여줍니다. 자세한 사용법은 다음예제를 통해 확인해 보겠습니다.
```c
#include <stdio.h>
#include <string.h> //문자열 관련 함수 원형을 모아 놓은 헤더 파일
int main(void)
{
    char str1[80] = "cat";
    char str2[80];

    strcpy(str1, "tiger"); //str1배열에 tiger 복사
    strcpy(str2, str1); //str2배열에 str1배열의 문자열 복사
    printf("%s, %s\n", str1, str2);

    return 0;
}
```
string.h는 문자열을 다루는 함수들의 원형을 모아놓은 것으로 strcpy 함수에 접근하기 위해 사용됩니다. strcpy 함수의 사용법은 다음과 같습니다.
#### strcpy(저장될 배열명, 저장할 문자열)
### strcpy함수로 문자열 상수를 char형 배열에 대입
9행의 strcpy함수는 str1 배열에 문자열 "tiger"를 복사해 저장합니다. 즉, 첫 번째 인수로는 저장될 곳의 배열명을 주고 두 번째 인수는 저장할 문자열을 사용합니다. 오른쪽에 있는 값을 왼쪽 변수에 대입하는 연산으로 생각해도 좋습니다.
#### 첫번째 인수는 문자열을 모두 저장할 수 있도록 충분히 커야 합니다. 아울러 첫 번째 인수에는 문자열 상수를 사용할 수 없습니다. 상수는 바뀌지 않는 값이므로 대입 연산자의 왼쪽에 올 수 없는 것과 같은 이유입니다.
### strcpy("lion", "tiger") <-이렇게 사용할 수 없다.
상수 문자열을 첫 번째 인수로 사용해도 컴파일 단계에서는 에러가 발생하지 않습니다. 그러나, 이는 실행할 때 문자가 생기므로 주의해야 합니다. 문자열이 포인터로 구현되기 때문에 생기는 문제입니다.
### 배열에 대입 연산자를 왜 사용할 수 없을까요?
```c
char str[80]; //배열 선언
str = "apple"; // 배열에 문자 대입
```
이 대입 연산식은 당연히 수행될 듯 하지만, 컴파일 단계에서 에러가 발생합니다. 대입 연산자 왼쪽에 사용한 배열명이 컴파일 과정에서 배열이 할당된 메모리의 주소값으로 바뀌기 때문입니다. 예를 들어 str배열이 메모리 100번지로부터 할당되었다면 다음과 같이 대입하는 것과 같습니다.
```c
100 = "apple";
```
100은 상수로 대입연산자의 왼쪽에 올 수 없으므로 컴파일 과정에서 에러가 발생합니다. 다만, strcpy 함수에서 사용할 수 있는 것은 strcpy 함수가 그 위치로 이동해 메모리의 공간을 사용하도록 구현되어 있기 때문입니다. 이 문제를 정확히 이해하기 위해서는 배열과 포인터의 관계를 배워야 합니다. 일단 여기서는 대입 연산자 왼쪽에 배열명이 올 수 없다는 사실만 기억하세요.

## 문자열 전용 입출력 함수 : gets, puts
char형 배열에 문자열을 대입하는 일은 strcpy함수가 훌륭히 수행합니다. 이제 키보드로 문자열을 입력하는 문제를 생각해보겠습니다. scanf 함수는 char형 배열에 문자열을 입력할 수 있으나 중간에 빈칸이 있는 경우 빈칸 전까지만 입력합니다. 따라서 빈칸을 포함해서 문자열을 입력할 수 있는 새로운 방식이 필요합니다.
#### gets 함수는 빈칸을 포함해 한 줄 전체를 문자열로 입력합니다. 또한 이 함수와 짝을 이루는 문자열 출력 함수 puts도 있습니다. 예제를 통해 puts와 gets함수의 사용법과 특징을 알아보겠습니다.
```c
#include <stdio.h>
int main(void)
{
    char str[80];

    printf("문자열 입력 : ");
    gets(str);
    puts("입력된 문자열 : ");
    puts(str);

    return 0;
}
```
gets 함수는 문자열 입력 중간에 빈칸이나 탭 문자르 사용할 수 있으며, enter를 누르기 전까지 전체를 하나의 문자열로 배열에 저장합니다. 물론 마지막에 널 문자를 붙여서 문자열의 끝을 표시합니다.
#### gets 함수의 사용법은 간단하지만 사용 시 주의할 점이 있습니다. 입력할 배열의 크기를 검사하지 않으므로 배열의 크기보다 긴 문자열을 입려하면 배열을 벗어난 메모리 영역을 침범할 가능성이 있습니다. 따라서 입력할 때 항상 배열의 크기를 고려해야 합니다. 이 문제는 scanf 함수나 strcpy 함수에도 해당되며 컴파일러에 따라 시스템 안전성 문제 때문에 컴파일을 제한하기도 합니다.
puts 함수는 문자열 상수나 char형 배열의 배열명을 주면 문자열을 화면에 출력합니다. printf 함수의 문자열 출력 기능과 같습니다. 단, 문자열을 출력한 후에 자동으로 줄을 바꾸는 차이가 있습니다. 이 기능은 경우에 따라 편할 수 있지만, 문자열을 출력한 후에 바로 이어서 입력하는 것은 불가능합니다.
## 문자열의 끝에 널 문자가 없다면?
printf 함수를 비롯한 많은 문자열 처리 함수가 널 문자로 문자열의 끝을 확인합니다. 따라서 char형 배열에 무엇을 저장하든 널 문자가 나올 때까지가 하나의 문자열입니다. 만약 필요한 곳에 널 문자가 없다면 문자열을 다루는 함수의 결과는 예상할 수 없습니다. 예제로 살펴보겠습니다.
```c
#include <stdio.h>

int main(void)
{
    char str[5];
    
    str[0] = 'O';
    str[1] = 'K';
    printf("%s\n", str);

    return 0;
}
```
5행에서 배열이 초기화되지 않았으므로 배열에는 쓰레기 값이 남아 있습니다. 여기에 7,8행에서 직접 문자를 넣고 printf 함수로 출력하니 OK가 저장된 다음 요소에 널 문자가 없어 쓰레기값을 출력합니다. 심지어 할당된 베열에 널 문자가 없으면 이어짐는 메모리 영역까지 출력합니다. 때로는 메모리 접근 에러가 발생하니 주의해야합니다. 그러므로, char형 배열에 문자를 하나씩 대입해 직접 문자열을 만드는 경우에는 문자열의 맨 끝에 널 문자를 저장해야 한다는 사실을 잊으면 안됩니다.

# 포인터의 기본 개념
지금까지 변수 선언으로 메모리에 공간을 확보하고, 그곳을, 데이터를 넣고 꺼내 쓰는 공간으로 사용했습니다. 변수명은 그런 메모리 공간을 식별할 수 있는 이름이었고요.

그러나 선언된 블록({}), 즉 함수 내부에서만 그 변수를 사용할 수 있었습니다. 같은 변수명을 사용했다 하더라도 블록이나 함수가 다르면 별도의 저장공간을 확보하므로 전혀 다른 변수로 사용되는 것이죠. 여기서는 사용 범위를 벗어난 경우에도 데이터를 공유할 수 있게 도와주는 포인터에 관해 알아보겠습니다.

## 메모리의 주소
메모리라는 것은 우리가 데이터를 넣고 꺼내 쓰는 공간으로, 그 위치를 식별할 수 있어야 합니다. 서랍 어딘가에 라면을 넣어 놓기는 했는데, 그것을 어느 사람에 넣어놨는지 찾을 수 없다면 먹을 수 없을 겁니다.
#### 다행히도 프로그램이 사용하는 메모리의 위치를 주소 값으로 식별할 수 있습니다. 메모리의 위치를 식별하는 주소 값은 바이트 단위로 구분됩니다. 이 값은 0부터 시작하고 바이트 단위로 1씩 증가하므로 2바이트 이상의 크기를 갖는 변수는 여러 개의 주소값에 걸쳐 할당됩니다.

예를 들어 int형 변수 a가 메모리 100번지에서 부터 할당 되었다면 100번지부터 103번까지 4바이트에 걸쳐 할당됩니다. 변수 선언 이후에는 4바이트 전체를 a라는 이름으로 사용합니다.

#### 따라서 a = 10;과 같은 문장은 메모리의 100번지부터 103번지까지 4바이트의 공간에 10을 저장하며, a + 20;과 같은 수식은 메모리 100번지부터 103번지까지 4바이트에 저장된 값과 20을 더하는 연산을 수행합니다.

결국 지금까지는 변수명으로 메모리 공간이나 값을 간단히 사용할 수 있었던 것이죠.

# 주소 연산자
이제 변수를 이름이 아닌 주소로 사용하는 방법을 살펴보겠습니다. 여기서 주소라 하면 할당된 메모리 공간의 시작 주소를 의미합니다. 시작 주소를 알면 그 위치부터 변수의 크기만큼 메모리를 사용할 수 있습니다. 주소는 주소 연산자 &를 사용해서 구합니다. 예제를 통해 &의 사용법을 익히고 변수가 할당된 메모리의 상태를 확인해 보겠습니다.
```c
#include <stdio.h>

int main(void)
{
    int a;
    double b;
    char c;

    printf("int형 변수의 주소 : %u\n", &a);
    printf("double형 변수의 주소 : %u\n", &b);
    printf("char형 변수의 주소 : %u\n", &c);

    return 0;

}
```
만약 메모리 변수가 어디에 할당되었는지 알고 싶다면 주소 연산자(&)를 사용하면 됩니다. 주소 연산자는 단항 연산자이며, 변수만을 피연산자로 사용해 시작 주소를 구합니다.
9행은 int형 변수 a의 주소를 출력한 것이므로 변수 a는 2,750,392번지부터 2,750,395번지 까지 4바이트에 할당되었을 겁니다.
### 메모리 주소의 출력 변환 문자
주소는 보통 16진수로 표기합니다. 따라서 주소를 출력할 때는 전용 변환 문자인 %p를 사용하는 것이 좋습니다. %p는 주소값의 데이터 크기에 따라 자릿수를 맞춰 16진수 대문자로 출력합니다. 만약 시스템에서 주소값 자체를 8바이트로 처리한다면 16진수 한 자리는 4비트에 해당하므로 주소값 10번지는 0000000000000000000A와 같이 6진수 16자리로 출력합니다. 여기서는 설명의 편의를 위해 주소값을 10진수로 출력하여 주소는 음수가 없으므로 %u 변환문자를 사용합니다.
## 포인터와 간접 참조 연산자
메모리의 주소는 필요할 때마다 계속 주소 연산을 수행하는 것보다 한 번 구한 주소를 저장해서 사용하면 편리한데, 포인터가 바로 변수의 메모리 주소를 저장하는 변수입니다. 따라서 주소를 저장할 포인터도 변수처럼 선언하고 사용합니다. 선언할 때는 변수 앞에 *만 붙여주면 됩니다.
```c
#include <stdio.h>

int main(void)
{
    int a; // {일반 변수 선언}
    int *pa; //자동으로 int*pa;로 위치가 조정되기도 합니다. 결과에는 영향이 없습니다. {포인트 선언}

    pa = &a; //포인터에 a의 주소 대입
    *pa = 10; //포인터로 변수 a에 10대입

    printf("포인터 a 값 출력 : %d\n", *pa);
    printf("변수명으로 a값 출력 : %d\n", a); // 변수 a값 출력

    return 0;
}
```
일반 변수명을 만드는 규칙에 따라 포인트 이름을 짓고, 변수명 앞에 *를 붙입니다. *는 포인터임을 표시하는 기호입니다. 그리고 자료형을 적는데, 주의할점은 주소 위치에 있는 변수의 자료형을 적어여한다는 것입니다.

예를 들어 int형 변수의 주소를 저장하면 int를 사용하고 double형 변수의 주소를 저장하면 double을 사용합니다. 5행에 선언된 변수의 형태가 int형이므로 int를 사용해서 포인터를 선언합니다.
### int(주소를 구한 변수의 형태) *(포인터 기호)pa(포인터 이름);
포인터 변수가 선언되면 일반 변수와 마찬가지로 메모리에 저장 공간이 할당되고 그 이후에는 변수명으로 사용할 수 있습니다. 8행은 포인터에 a의 시작 주소를 저장하는 문장입니다.
#### 이제 포인터 pa는 변수 a가 메모리 어디에 할당되어 있는지 그 위치를 기억하고 있습니다. 이렇게 포인터가 어떤 변수의 주소를 저장한 경우 '가리킨다'고 말하며 둘의 관계를 pa -> a처럼 화살표로 간단히 표현합니다. 반대로 만약 x -> y로 표현한다면 'x는 y를 가리킨다'고 말할 수 있고 x는 포인터이며 변수 y의 주소를 저장하고 있다는 뜻이 됩니다.

포인터가 어떤 변수를 가리키면 포인터로 가리키는 변수를 사용할 수 있습니다. 즉, 포인터 pa로 변수 a를 사용할 수 있습니다. 포인터가 가리키는 변수를 사용할 때는 포인터에 특별한 연산자를 사용하는데, 이를 간접 참조 연산자(*) 또는 포인터 연산자라고 합니다.
#### 포인터 pa가 a를 가리키므로 *pa에 10을 대입하면 결국 a에 10을 대입하는 것과 같습니다.

## 여러가지 포인터 사용해보기
포인터가 어떤 변수를 가리키게 되면 그 이후에는 간접 참조 연산자를 통해 가리키는 변수를 자유롭게 쓸 수 있습니다. 예제를 통해 다양한 포인터의 사용법을 살펴보겠습니다.
```c
#include <stdio.h>

 int main(void)
 {
    int a = 10, b = 15, total;
    double avg;
    int *pa, *pb;
    int *pt = &total;
    double *pg = &avg;
    
    pa = &a;
    pb = &b;

    *pt = *pa + *pb
    *pg = *pt / 2.0

    printf("두 정수의 값 : %d, %d\n", *pa, *pb);
    printf("두 정수의 합 : %d\n", *pt);
    printf("두 점수의 평균 : %.1lf\n", *pg);

    return 0;
 }
 ```

 # const를 사용한 포인터
 const 예약어를 포인터에 사용하면 이는 가리키는 변수의 값을 바꿀 수 없다라는 의미로, 변수에 사용하는 것과는 다른 의미를 가집니다.
 ```c
 #include <stdio.h>
 int main(void)
 {
    int a = 10, b = 20;
    const int *pa = &a; //포인터 pa는 변수 a를 가리킨다.

    printf("변수 a의 값 : %d\n", *pa); //포인터를 간접 참조해 a 출력
    pa = &b; //포인터가 변수 b를 가리키게 한다.
    printf("변수 b의 값 : %d\n", *pa); //포인터를 간접 참조해 b값 출력
    pa = &a; //포인터가 다시 변수 a를 가리킨다.
    a = 20; //a를 직접 참조해 값을 바꾼다.
    printf("변수 a의 값 : %d\n", *pa); //포인터로 간접 참조해 바뀐 값 출력

    return 0;
 }
 ```
 만약 const가 일반 변수처럼 포인터 값을 고정시킨다면 9행에서 pa는 다른 변수의 주소를 저장할 수 없습니다. 그러나 출력결과에서 pa는 const의 사용과는 무관하게 변수 b의 주소를 저장하고 그 값을 간접 참조해 출력하고 있습니다. 그렇다면 포인터에 사용된 const의 의미는 무엇일까요? 바로 pa가 가리키는 변수 a는 pa를 간접 참조해 바꿀 수 없다는 것입니다. 만약 12행에서 *pa=20;과 같이 pa를 통해 a값을 바꾸고자 한다면 에러메시지가 출력됩니다.

 # 포인터에 const를 사용하는 이유
 변수 a는 어디까지나 포인터를 통해서만 바꿀 수 없으며 변수 a 자체를 사용하면 얼마든지 바꿀 수 있습니다. 이쯤에서 포인터에 const를 사용하는 이유가 궁금해질 겁니다. 포인터에 const를 사용하는 대표적인 예는 문자열 상수를 인수로 받는 함수입니다. 문자열 상수는 값이 바뀌면 안되므로 함수의 매개변수를 통해서 값을 바꿀 수 없도록, 매개변수로 선언된 포인터에 const를 사용합니다.
 ```